{"meta":{"title":"CNKCQ","subtitle":null,"description":null,"author":"CNKCQ","url":"http://cnkcq.github.io"},"pages":[],"posts":[{"title":"SideNavigation——今晚不加班😂","slug":"SideNavigation——今晚不加班😂","date":"2017-09-22T01:48:13.000Z","updated":"2017-09-22T08:01:40.058Z","comments":true,"path":"2017/09/22/SideNavigation——今晚不加班😂/","link":"","permalink":"http://cnkcq.github.io/2017/09/22/SideNavigation——今晚不加班😂/","excerpt":"前言&emsp;&emsp;在 Android app 中，侧边栏的应用是非常普遍的，从 Google 的官方 UI 设计指南中可以看出这种设计对 UI || UED 的引导，不仅如此，Google 自家的应用也对侧边栏进行了广泛的实践，inbox gmail 就是其中之一。因此，你也可能遇到有一天你的 UI || UED 跑过来对你说我们 iOS 也支持一下 “侧边栏” 导航吧。如果你有这个需求又恰好看到这篇文章，那么恭喜你，本来可能需要加班的你可以解放了。","text":"前言&emsp;&emsp;在 Android app 中，侧边栏的应用是非常普遍的，从 Google 的官方 UI 设计指南中可以看出这种设计对 UI || UED 的引导，不仅如此，Google 自家的应用也对侧边栏进行了广泛的实践，inbox gmail 就是其中之一。因此，你也可能遇到有一天你的 UI || UED 跑过来对你说我们 iOS 也支持一下 “侧边栏” 导航吧。如果你有这个需求又恰好看到这篇文章，那么恭喜你，本来可能需要加班的你可以解放了。 正文&emsp;&emsp;如上图，像这样的效果实现方式很多，我们项目中原来就有实现过，既然实现过，那么为什么还要去实现一遍呢？这就要从我苦逼的 iPad 适配之旅开始讲了，我们的项目是一个 OC + Swift + RN + H5 的一个混合项目，适配起来那个酸爽别提了，侧边是由 OC 写的老旧代码，在 iPad 的横竖屏适配上特别糟糕😰，于是我决定用 Swift 封装一个 SideNavigation 的轮子。为了满足需求这个轮子应该具备以下特点： 横竖屏适配，满足 iPad 适配需求 支持 Swift &amp;&amp; OC 满足混编需求 用户可以通过向右或者向左滑动呼出侧边栏 用户还可以通过拖拽关闭侧边栏 接口要简单&emsp;&emsp;把复杂留给自己，简单留给他人，好的接口大底应该如此。如：12public convenience init(_ viewController: UIViewController, left: UIViewController) public convenience init(_ viewController: UIViewController, right: UIViewController) 由上可知，我们只需要通过初始化一个 SideMenuManager 就能实现你想要的侧边抽屉效果，实在是太方便了😂。 实现&emsp;&emsp;(1) 实现 UIViewControllerTransitioningDelegate&emsp;&emsp; 我们可以通过 UIViewControllerTransitioningDelegate 来实现转场动画： 1234567891011121314151617181920212223242526272829public func presentationController(forPresented presented: UIViewController, presenting: UIViewController?, source: UIViewController) -&gt; UIPresentationController? &#123; let presentationController = PresentationController(presentedViewController: presented, presenting: presenting) presentationController.delegate = self presentationController.direction = direction self.dismissInteractor = PercentDrivenInteractiveTransition(self.presentController, with: presentationController.dimmingView, present: nil, direction: self.direction) return presentationController&#125;public func animationController(forDismissed dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; let animator = AnimatedTransitioning() animator.direction = direction animator.transitionType = .dismiss return animator&#125;public func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; let animator = AnimatedTransitioning() animator.direction = direction animator.transitionType = .present return animator&#125;public func interactionControllerForDismissal(using animator: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning? &#123; return self.dismissInteractor.isInteractiveTransition ? self.dismissInteractor : nil&#125;public func interactionControllerForPresentation(using animator: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning? &#123; return self.presentInteractor.isInteractiveTransition ? self.presentInteractor : nil&#125; 通过使用 SideNavigation 我们可以知道，我们的侧边效果是通过转场来实现的，要达到侧边栏的效果，我们可以自定义转场动画，👆代码中的代理就是转场协议的实现，包括对 non-interactive 和 interactive 动画进行自定义实现。 （2）自定义 UIPresentationController&emsp;&emsp; 在 public func presentationController(forPresented presented: UIViewController, presenting: UIViewController?, source: UIViewController) -&gt; UIPresentationController? 函数中我们需要返回一个指定的 UIPresentationController, 当然，我们这里需要对我们的 UIPresentationController 适当的做一些改造来满足我们的需求: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// MARK: - Initializers override init(presentedViewController: UIViewController, presenting presentingViewController: UIViewController?) &#123; super.init(presentedViewController: presentedViewController, presenting: presentingViewController) &#125; override var frameOfPresentedViewInContainerView: CGRect &#123; var frame: CGRect = super.frameOfPresentedViewInContainerView switch direction &#123; case .right: frame.origin.x = frame.size.width / 3 default: break &#125; frame.size = size(forChildContentContainer: presentedViewController, withParentContainerSize: containerView!.bounds.size) return frame &#125; override func containerViewWillLayoutSubviews() &#123; presentedView?.frame = frameOfPresentedViewInContainerView &#125; override func size(forChildContentContainer container: UIContentContainer, withParentContainerSize parentSize: CGSize) -&gt; CGSize &#123; return CGSize(width: parentSize.width*(2.0/3.0), height: parentSize.height) &#125; override func presentationTransitionWillBegin() &#123; containerView?.insertSubview(dimmingView, at: 0) NSLayoutConstraint.activate(NSLayoutConstraint.constraints(withVisualFormat: \"V:|[dimmingView]|\", options: [], metrics: nil, views: [\"dimmingView\": dimmingView])) NSLayoutConstraint.activate(NSLayoutConstraint.constraints(withVisualFormat: \"H:|[dimmingView]|\", options: [], metrics: nil, views: [\"dimmingView\": dimmingView])) guard let coordinator = presentedViewController.transitionCoordinator else &#123; dimmingView.alpha = 1.0 return &#125; coordinator.animate(alongsideTransition: &#123; _ in self.dimmingView.alpha = 1.0 &#125;) &#125; override func dismissalTransitionWillBegin() &#123; guard let coordinator = presentedViewController.transitionCoordinator else &#123; dimmingView.alpha = 0.0 return &#125; coordinator.animate(alongsideTransition: &#123; _ in self.dimmingView.alpha = 0.0 &#125;) &#125; lazy var dimmingView: UIView = &#123; let dimming = UIView() dimming.translatesAutoresizingMaskIntoConstraints = false dimming.backgroundColor = UIColor(white: 0.0, alpha: 0.5) dimming.alpha = 0.0 let recognizer = UITapGestureRecognizer(target: self, action: #selector(handleTap(recognizer:))) dimming.addGestureRecognizer(recognizer) return dimming &#125;() @objc dynamic func handleTap(recognizer: UITapGestureRecognizer) &#123; presentingViewController.dismiss(animated: true) &#125; 在自定义的 UIPresentationController 的过程中，我们对 presentedView 的 frame 进行简单的更改，已达到我们的期望。从效果图中我们也看到，我们还需要一个 dimmingView 来实现半透明效果，这里我们还未它添加了一个手势以便于 dismiss 抽屉。 （3）实现 UIViewControllerAnimatedTransitioning &emsp;&emsp; public func animationController(forDismissed dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? 需要返回一个 UIViewControllerAnimatedTransitioning 这里我们来初略的看一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval &#123; return kAnimationDuration&#125;func animateTransition(using transitionContext: UIViewControllerContextTransitioning) &#123; let from = transitionContext.viewController(forKey: UITransitionContextViewControllerKey.from) let to = transitionContext.viewController(forKey: UITransitionContextViewControllerKey.to) switch transitionType &#123; case .present: animatePresenting(in: transitionContext, to: to!, from: from!) case .dismiss: animateDismissing(in: transitionContext, to: to!, from: from!) &#125;&#125;func animatePresenting(in transitionContext: UIViewControllerContextTransitioning, to: UIViewController, from: UIViewController) &#123; var fromRect = transitionContext.initialFrame(for: from) var toRect = fromRect switch direction &#123; case .left: toRect.origin.x = -toRect.width / 3 * 2 // for the edge panGesture if #available(iOS 11, *) &#123; // it's maybe a bug of iOS 11, it should be checked some time fromRect = CGRect(x: fromRect.minX - (toRect.width / 3)/2, y: fromRect.minY, width: fromRect.width, height: fromRect.height) &#125; case .right: toRect.origin.x = toRect.width / 3 * 2 if #available(iOS 11, *) &#123; // it's maybe a bug of iOS 11, it should be checked some time fromRect = CGRect(x: fromRect.minX + (toRect.width / 3)/2, y: fromRect.minY, width: fromRect.width, height: fromRect.height) &#125; &#125; to.view.frame = toRect transitionContext.containerView.addSubview(to.view) UIView.animate(withDuration: kAnimationDuration, animations: &#123; to.view.frame = fromRect &#125;) &#123; (_) in if transitionContext.transitionWasCancelled &#123; transitionContext.completeTransition(false) &#125; else &#123; transitionContext.completeTransition(true) &#125; &#125;&#125;func animateDismissing(in transitionContext: UIViewControllerContextTransitioning, to: UIViewController, from: UIViewController) &#123; var fromRect = transitionContext.initialFrame(for: from) switch direction &#123; case .left: fromRect.origin.x = -fromRect.width case .right: fromRect.origin.x = fromRect.width &#125; UIView.animate(withDuration: kAnimationDuration, animations: &#123; from.view.frame = fromRect &#125;) &#123; (_) in if transitionContext.transitionWasCancelled &#123; transitionContext.completeTransition(false) &#125; else &#123; transitionContext.completeTransition(true) &#125; &#125;&#125; 从 animatePresenting 以及 animateDismissing 我们可以清晰的看到，这里就是对转场这个过程的 start 到 end 过程的位置状态做一个约束，然后在辅以简单的动画。 （4）UIPercentDrivenInteractiveTransition 的继承&emsp;&emsp; 还记得我们在第一步实现的 func interactionControllerForDismissal(using animator: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning? &amp;&amp; func interactionControllerForPresentation(using animator: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning? 这两个函数吗？我们的用户交互效果就是通过这两个函数来实现的，在这里我们对 UIPercentDrivenInteractiveTransition 进行自定义： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485 convenience init(_ viewController: UIViewController, with view: UIView?, present: UIViewController?, direction: Direction? = .left) &#123; self.init() self.viewController = viewController self.direction = direction ?? .left self.presentViewController = present if self.presentViewController != nil &#123; switch self.direction &#123; case .left: let edgePanGesture = UIScreenEdgePanGestureRecognizer(target: self, action: #selector(onPan(sender:))) edgePanGesture.edges = .left edgePanGesture.delegate = self self.viewController.view.addGestureRecognizer(edgePanGesture) case .right: let edgePanGesture = UIScreenEdgePanGestureRecognizer(target: self, action: #selector(onPan(sender:))) edgePanGesture.edges = .right edgePanGesture.delegate = self self.viewController.view.addGestureRecognizer(edgePanGesture) break &#125; &#125; else &#123; let panGesture = UIPanGestureRecognizer(target: self, action: #selector(onPan(sender:))) view?.addGestureRecognizer(panGesture) let dismissPanGesture = UIPanGestureRecognizer(target: self, action: #selector(onPan(sender:))) self.viewController.view.addGestureRecognizer(dismissPanGesture) &#125; &#125; func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -&gt; Bool &#123; /// to avoid the interactivePopGestureRecognizer of UINavigationController if let nav = viewController as? UINavigationController &#123; return nav.viewControllers.count &lt; 2 &#125; return true &#125; @objc func onPan(sender: UIPanGestureRecognizer) &#123; let translation = sender.translation(in: sender.view?.superview) switch sender.state &#123; case .began: self.isInteractiveTransition = true if self.presentViewController != nil &#123; self.viewController.present(self.presentViewController!, animated: true, completion: nil) &#125; else &#123; self.viewController.dismiss(animated: true, completion: nil) &#125; case .changed: let screenWidth = -UIScreen.main.bounds.size.width var dragAmount = self.presentViewController == nil ? screenWidth : -screenWidth switch direction &#123; case .left: dragAmount = self.presentViewController == nil ? screenWidth : -screenWidth case .right: dragAmount = self.presentViewController != nil ? screenWidth : -screenWidth &#125; let threshold: CGFloat = 0.20 var percent = translation.x / dragAmount percent = max(percent, 0.0) percent = min(percent, 1.0) update(percent) self.shouldComplete = percent &gt; threshold case .cancelled, .ended: self.isInteractiveTransition = false if self.shouldComplete == false || sender.state == .cancelled &#123; cancel() &#125; else &#123; finish() &#125; default: break &#125; &#125;``` 对 `UIPercentDrivenInteractiveTransition` 自定义的主要目的是对 转场动效的更新过程进行控制：```swift // These methods should be called by the gesture recognizer or some other logic // to drive the interaction. This style of interaction controller should only be // used with an animator that implements a CA style transition in the animator's // animateTransition: method. If this type of interaction controller is // specified, the animateTransition: method must ensure to call the // UIViewControllerTransitionParameters completeTransition: method. The other // interactive methods on UIViewControllerContextTransitioning should NOT be // called. If there is an interruptible animator, these methods will either scrub or continue // the transition in the forward or reverse directions. open func update(_ percentComplete: CGFloat) 正是如此，我们在 UIPercentDrivenInteractiveTransition 的自定义过程中，通过对 中间视图和侧边视图添加手势来控制转场 update 的进度。&emsp;&emsp;看看项目中的使用效果： 总结&emsp;&emsp;实现一个简易的侧边抽屉效果还是很简单的，我们通过实现专场协议，自定义转场动画，添加滑动手势，设置转场始末位置状态，就可以轻松搞定侧边栏。 Project 水平有限，如有疏漏，望指正欢迎交流，欢迎 star CNKCQ遗人🌹，手有余香 blog","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://cnkcq.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://cnkcq.github.io/tags/Swift/"},{"name":"Menu","slug":"Menu","permalink":"http://cnkcq.github.io/tags/Menu/"}]},{"title":"MacBook——如何快速配置 iOS 开发环境","slug":"MacBook——如何快速配置 iOS 开发环境","date":"2017-09-04T18:05:13.000Z","updated":"2017-09-22T08:01:40.058Z","comments":true,"path":"2017/09/04/MacBook——如何快速配置 iOS 开发环境/","link":"","permalink":"http://cnkcq.github.io/2017/09/04/MacBook——如何快速配置 iOS 开发环境/","excerpt":"前言 &emsp;&emsp;作为一名开发者，我相信你对开发环境的配置并不陌生，无论你是 J2EE、 Android 还是 iOS 开发者，拿到新电脑后第一件事情也就是去配置开发环境。如果你是一名开发老司机，你可能会熟练的配置好开发环境并迅速的就能进行开发，但对于 freshman 来说这个过程就有点漫长或者说是相当痛苦的。我们都是比较懒的，这么繁杂的配置，我们为什么不可以用一个脚本让他自动执行呢？","text":"前言 &emsp;&emsp;作为一名开发者，我相信你对开发环境的配置并不陌生，无论你是 J2EE、 Android 还是 iOS 开发者，拿到新电脑后第一件事情也就是去配置开发环境。如果你是一名开发老司机，你可能会熟练的配置好开发环境并迅速的就能进行开发，但对于 freshman 来说这个过程就有点漫长或者说是相当痛苦的。我们都是比较懒的，这么繁杂的配置，我们为什么不可以用一个脚本让他自动执行呢？ 正文 &emsp;&emsp;作为Mac 上有很多激动人心的工具，我们会时常去收集，并在不断的尝试去更新自己的开发工具库。如果你不是独立开发者，那么也就意味着你有一个团队，为了协同工作，我们通常也会在团队中形成一套统一的开发工具集。因此我们可以在 git 上创建一个工程去管理我们的开发环境。那么就让我们简单的来完成一个这样的项目吧。做为 iOS 开发者，去 App store 下载并安装 Xcode，这一步不可避免👻，紧接着，安装 Xcode command line tools，运行： 1xcode-select --install 这一步将完成 Xcode command line tools 的安装。本工程主要通过 fabric + shell 实现脚本自动化，所以我们还需安装 fabic 环境: 12sudo easy_install -U pipsudo pip install Fabric -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com 根据这行命令的的指引，我们将成功安装 Fabric。看到这里，也许你会问，Fabric 是嘛玩意，对我们有什么帮助？ Fabric &emsp;&emsp;作为Fabirc 是基于 python 实现的 SSH 命令行工具, 在自动化部署领域有着非常广泛的应用。 那么怎么使用呢？在默认情况下使用 Fabric 我们需要在跟目录下创建 fabfile.py 入口文件，然后我们就可以在这个文件里进行脚本编写了。在文件开头我们首先导入我们所需要使用的 Fabric 库： 12345678import osimport sysfrom fabric.colors import blue, cyan, green, magenta, red, yellowfrom fabric.decorators import taskfrom fabric.operations import localfrom fabric.state import envfrom fabric.utils import puts 这里我们队 Fabric 导入的接口进行简要的说明： api 说明 colors 需要的颜色选定 local 配合 Shell 执行本地命令 env fabfile 的全局参数定义 puts 打印相当于 Swift 中的 print 函数 task 被 @task 修饰的函数可以用 fab command 调用 了解 Fabric 后我们来做一个 help 命令： 1234567891011121314# ============# = Help =# ============@task(default=True, alias='help')def help(): \"\"\" look up the help doc \"\"\" puts('*' * 60) puts('* ' + cyan(' Fabric helps '.center(58, '=')) ) puts('*' + ' ' * 58 ) puts('*' + green(' lookup all the Commands: fab -l'.ljust(64))) puts('*' + green(' lookup the detail of a specific command: fab -d command'.ljust(64)) ) puts('*' + yellow(' execute a command with para: fab command: para'.ljust(70))) puts('*' + ' ' * 58 ) puts('*' * 60) 接下来我们来看看这个 help 命令的运行效果： 这是一个好的开始。 softwares &emsp;&emsp;作为我们知道 fabric + shell 的简单使用可以实现一个自动化脚本，那么我们到底要用这个脚本安装哪些 software 呢？其实这个是因人而异的，这里我简单罗列一下我所使用的一些工具，您如果有更好的工具，请推荐给我： Homebrew &emsp;&emsp;作为主流的 Linux 都有包管理器， Red hat 有 yum，Ubuntu 有 apt-get，但不好意思，Mac OS 没有这玩意，Homebrew —— Mac OS 缺失的软件包管理器，那么它 能干什么呢? 当然是管理 Mac OS 上的软件包。比如说我想安装 wget ： 1$ brew install wget 想卸载： 1$ brew uninstall wget 我们可以看到有了 Homebrew ，我们可以轻松的管理这些软件包。 Oh My ZSH&emsp;&emsp;其实 OS X 默认的 bash 已经非常强大了，但是你绝不会拒绝更优秀的 ZSH 。关于为什么使用 ZSH ，请移步 使用zsh的十大优点 。由于 ZSH 的配置实在太复杂了，于是就出现了 Oh My ZSH , 有了它，我们可以轻松的配置我们的 zsh 了： 1curl -L https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh | sh CocoaPods&emsp;&emsp; CocoaPods ，对于大家来说，我想并不陌生，它经常能帮助你快速的管理你的三方开源库，包括 install、update 等操作。 因此 CocoaPods 也是我们开发中必不可少的一个工具： 1sudo gem install cocoapods ……常用的软件，我想我就不一一列举了，大家都有自己的习惯，和常用的软件。 脚本化&emsp;&emsp;我们定义一个 install 函数，并将我们所要安装的软件通过脚本来顺序安装 ，并用 @task 标记： 1234567891011121314151617181920212223242526\"\"\"install the group of software, example: fab install:ios\"\"\"if not os.path.exists('/usr/local/bin/brew'): puts(green('install Homebrew')) local('ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"')puts(green('install proxy'))local('brew install proxychains-ng')local('sed -i \"\" \"s/socks4[[:space:]][[:space:]]127.0.0.1[[:space:]]9050/socks5 127.0.0.1 1086/g\" /usr/local/etc/proxychains.conf')local('brew install bash-completion ruby tree')local('brew link --overwrite ruby')puts(green('config RubyGems'))local('gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/')local('gem sources -l')puts(green('install BearyChat, GitHub Desktop, Google Chrome, ShadowsocksX-NG'))local('brew cask install bearychat github-desktop google-chrome shadowsocksx-ng')puts(green('install Atom, Charles, Dash'))local('brew cask install atom charles dash')puts(green('install CocoaPods'))local('sudo gem install cocoapods')puts(green('install Carthage, SwiftLint'))local('brew install carthage swiftlint')puts(green('install fastlane'))local('sudo gem install fastlane -NV')local('brew cleanup')local('brew cask cleanup')local('sudo gem clean') 如上代码，会逐行执行，等这段脚本执行完，这些软件也就安装好了。同理，我们还可以定义一个用于软件更新的函数 update ： 12345678910111213141516@taskdef update(proxy=True, pypi_option=env.pypi_option): \"\"\"update the tools to the latest version\"\"\" puts(green('update Homebrew')) local('brew upgrade') local('brew cleanup') puts(green('update pip, Pylint, Transifex Command-Line Tool, virtualenvwrapper, twine, Fabric')) # https://github.com/Homebrew/legacy-homebrew/issues/25752 try: local('sudo -H pip3 install -U pip pylint transifex-client twine virtualenvwrapper&#123;&#125;'.format(pypi_option)) except Exception: pass local('sudo -H pip2 install -U pip&#123;&#125;'.format(pypi_option)) local('sudo -H pip install -U --user Fabric&#123;&#125;'.format(pypi_option)) # https://github.com/pypa/pip/issues/3165 puts(green('update RubyGems')) local('sudo gem update') local('sudo gem clean') 这样，我们就可以通过脚本定期更新我们的软件了。 水平有限，如有疏漏，望指正欢迎交流，欢迎 star CNKCQ遗人🌹，手有余香 blog","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://cnkcq.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://cnkcq.github.io/tags/Swift/"},{"name":"Mac","slug":"Mac","permalink":"http://cnkcq.github.io/tags/Mac/"}]},{"title":"iOS 11 ——迟来的 NFC","slug":"iOS 11 ——迟来的 NFC","date":"2017-09-01T02:48:13.000Z","updated":"2017-09-22T08:01:40.058Z","comments":true,"path":"2017/09/01/iOS 11 ——迟来的 NFC/","link":"","permalink":"http://cnkcq.github.io/2017/09/01/iOS 11 ——迟来的 NFC/","excerpt":"前言 NFC 这个词已经并不陌生了，前一段时间北京地铁支持 NFC 支付一时成为霸占头条的热点。其实在 90 年代末到 2000 年初，二维码和 NFC 就已经相继诞生，由于二维码成本低廉，技术门槛相对较低，因此，二维码迅速抢占了移动支付的市场，但 NFC 的发展并未因此停止。在 Android 端的 NFC 发展已经非常迅猛了，可惜 Apple 迟迟为开放接口，在今年的 WWDC 上，苹果宣布开放其 NFC 接口 CoreNFC, 这为以后 NFC 的应用提供了更多的可能。","text":"前言 NFC 这个词已经并不陌生了，前一段时间北京地铁支持 NFC 支付一时成为霸占头条的热点。其实在 90 年代末到 2000 年初，二维码和 NFC 就已经相继诞生，由于二维码成本低廉，技术门槛相对较低，因此，二维码迅速抢占了移动支付的市场，但 NFC 的发展并未因此停止。在 Android 端的 NFC 发展已经非常迅猛了，可惜 Apple 迟迟为开放接口，在今年的 WWDC 上，苹果宣布开放其 NFC 接口 CoreNFC, 这为以后 NFC 的应用提供了更多的可能。 正文 如果你对 NFC 这项技术还比较陌生，那么这里科普一下，NFC（Near Field Communication）近场通信，当两个设备相互靠近时能进行信息交流。许多企业讲 NFC 芯片放到卡片里，用带有 NFC 芯片的卡片来授予权限将允许谁有权限，比如说进出入公司。Apple CoreNFC 目前支持的格式有限，NFC 数据交换格式或 NDEF（通常用于当今市场上的大多数平板电脑和手机），比如 Apple Pay 。 CoreNFC Demo 这里我们通过一个简单的实例程序来演示怎么使用 CoreNFC，这个程序可以用来读取存储在卡片上 NDEF 格式的信息。 为此，我使用 Arduino Uno 与 Adafruit PN532 Shield 配对，将其发送到样品 NDEF 格式的卡上。 如果你不具备这些东西，或者根本不想在这样的硬件上投入时间和金钱，请尝试找一张带有信息的预格式化卡。 本文中，我不会演示 NFC 格式化以及如何把数据存储到 NDEF 卡 中。 Getting Started 打开 Xcode 9 创建一个简单的 Swift 工程。使用 Storyboard 创建简单的页面： ViewController 如下： 123456789101112131415161718192021import UIKit class ViewController: UIViewController &#123; @IBOutlet weak var messageLabel: UILabel! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; @IBAction func scanPressed(_ sender: Any) &#123; // this is our newly created IBAction &#125; &#125; Entitlements &amp; Privacy 我们的 app 要使用 NFC 必须进行应用授权：前提是你得有一个有效 Apple id （交过保护费的). 进行应用程序授权和隐私设置，打开developer.apple.com。 登录你的帐户，创建一个证书 —— 注册一个新的 APP ID。应用说明应该要支持 NFC 点击下一步，确保你的确认页面如下图： 然后再创建 provisioning profile ： 这一步完成了，在我们刚创建的项目中导入 证书和描述文件，完成之后呢，我们还需进行 Info.plist 配置 Privacy： 至此，我们的开始工作就完成了。👇我们进入 coding 阶段。 Core NFC 要实现 NFC 功能，我们得接入 Core NFC framework： 1import CoreNFC 目前为止，iOS模拟器尚未支持 CoreNFC。 这意味着如你尝试导入CoreNFC，会收到一条错误，表示没有名为 CoreNFC 的模块。 遇到这种情况，请选择你的 iPhone 或 Generic iOS Device。接下来我们实现 NFCNDEFReaderSessionDelegate 协议： 123456789101112131415161718192021222324252627282930import UIKitimport CoreNFC class ViewController: UIViewController, NFCNDEFReaderSessionDelegate &#123; @IBOutlet weak var messageLabel: UILabel! var nfcSession: NFCNDEFReaderSession? override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; @IBAction func scanPressed(_ sender: Any) &#123; &#125; func readerSession(_ session: NFCNDEFReaderSession, didInvalidateWithError error: Error) &#123; print(\"The session was invalidated: \\(error.localizedDescription)\") &#125; func readerSession(_ session: NFCNDEFReaderSession, didDetectNDEFs messages: [NFCNDEFMessage]) &#123; // Parse the card's information &#125;&#125; 其中两个 readerSession 函数会分别告诉我们 NFC 会话成功或失败，成功后则返回 NFCNDEFMessage 格式的通信数据，失败后会返回 error 信息。 当然，我们首先还需要初始化 NFCNDEFReaderSession 并开启 NFC 监听。 1234@IBAction func scanPressed(_ sender: Any) &#123; nfcSession = NFCNDEFReaderSession.init(delegate: self, queue: nil, invalidateAfterFirstRead: true) nfcSession?.begin()&#125; 然后运行程序，看看： 如果提示 Session is invalidated unexpectedly ，那么请仔细核对 证书、描述文件以及 Privacy 设置是否正确。这个过程并不难，简单几步就能搞定，下面我们来看看怎么解析获取到的 message 。 解析 Message 首先，让我们来看一下这个函数：1func readerSession(_ session: NFCNDEFReaderSession, didDetectNDEFs messages: [NFCNDEFMessage]) 让我们来看看每一个 message 对象包含了哪些信息： 1print(messages[0]) 我们可以看到： 123456( // Payload one (There's only one payload in this card) \"TNF=1, /* Type Name Format */ Payload Type=&lt;55&gt;, Payload ID=&lt;&gt;, Payload=&lt;0048656c 6c6f21&gt;\" /* What we're really interested in */) 根据打印的结果我们可以看出：. messages 是一个 NFCNDEFMessages 对象的数组。. NFCNDEFMessage 有一个 NFCNDEFPayload 对象数组 records然后我们再来看看每一个 payload 又包含了哪些信息： identifier. type. typeNameFormat. payload. 这里其实我们只关心 payload 。好了，看看如何解析 records 吧。 12345678910func readerSession(_ session: NFCNDEFReaderSession, didDetectNDEFs messages: [NFCNDEFMessage]) &#123; var result = \"\" for payload in messages[0].records &#123; result += String.init(data: payload.payload.advanced(by: 3), encoding: .utf8)! // 1 &#125; DispatchQueue.main.async &#123; self.messageLabel.text = result &#125;&#125; 来看看最终的效果： 参考Working with CoreNFC in iOS 11 水平有限，如有疏漏，望指正欢迎交流，欢迎 star CNKCQ遗人🌹，手有余香 blog","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://cnkcq.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://cnkcq.github.io/tags/Swift/"},{"name":"NFC","slug":"NFC","permalink":"http://cnkcq.github.io/tags/NFC/"}]},{"title":"Xcode 9 —进阶的 iOS Simulator","slug":"Xcode 9 —进阶的 iOS Simulator","date":"2017-08-15T01:05:13.000Z","updated":"2017-09-22T08:01:40.058Z","comments":true,"path":"2017/08/15/Xcode 9 —进阶的 iOS Simulator/","link":"","permalink":"http://cnkcq.github.io/2017/08/15/Xcode 9 —进阶的 iOS Simulator/","excerpt":"前言 iOS Simulator 是 iOS 开发过程中不可或缺的一部分，我平时工作中也有很大一部分时间在使用 iOS Simulator， 相比于 Android ，iOS Simulator 具有启动时间快，运行效率高等显著的特点。 因此，用好 iOS Simulator 对于提高我们的开发效率是有很大帮助的. Xcode 9 中，有一大堆新特新等你来撩！！","text":"前言 iOS Simulator 是 iOS 开发过程中不可或缺的一部分，我平时工作中也有很大一部分时间在使用 iOS Simulator， 相比于 Android ，iOS Simulator 具有启动时间快，运行效率高等显著的特点。 因此，用好 iOS Simulator 对于提高我们的开发效率是有很大帮助的. Xcode 9 中，有一大堆新特新等你来撩！！ 正文1、 在 Xcode 的全屏模式下使用 Simulator 如果你用的是 13 寸的电脑，那么 Xcode 的全屏模式你应该早已习惯，其实即使是配有显示器，我还是习惯在 Xcode 的全屏模式下开发😎。很可惜的是不能在 Xcode 的全屏模式下使用 Simulator, 自 Xcode 9b3 以后，这个问题便不存在了： 这个功能并不是对所有人默认开放的，如果不幸你的 Xcode 没有默认开启这个功能也不要灰心，我们可以通过打开 Apple Internal menu 来启用这个功能，通过 Apple Internal menu 你能挖掘出 Simulator 的更多新特性。那么问题来了，怎么开启 Apple Internal menu 呢？首先，在更目录里创建 AppleInternal 文件夹，然后重启 Simulator: 12cd ~/sudo mkdir /AppleInternal 重启 Simulator 后就可以看到 internal 选项 ☝️再次重申，你需要下载 Xcode 9b3 或更新的版本才行 2、同时打开多个模拟器 还记以前我们在不同尺寸的手机上去适配吗？通常情况下，我们通过 Storyboard 可以直观的看到 View 在不同尺寸设备上的形态，然而纯 Code 码出的界面就得多次启动不同的模拟器来进行可视化调试了。作为开发者，你肯定也想过，要是能同时启动多个模拟器多好，那么很高兴的告诉你，在 Xcode 9 中这已不再是问题了。 3、拖动放大或缩小 Simulator 在 Xcode 9 之前， 我们需要通过 command + 1、2、3、4 来对 Simulator 的大小进行调整，Xcode 9 以后就不用这么麻烦，我们可以通过拖拽来控制模拟器的大小了。如果您有多个模拟器打开，这是非常有用的一些细节，它可以帮助你有效地组织工作空间。 4、Simulator 屏幕捕捉 在 Apple 官方的 “What’s new” Xcode 9 文档中，苹果声称现在可以录制模拟器屏幕的视频。 其实这并不新鲜，即使在旧版本中我们也可以通过 simctl 实现这样的功能。 您可以从界面启用视频录制（除了iOS 11中的内置屏幕录制）。 执行 command 的命令，就可以得到我们想要录制的视频了。 1xcrun simctl io booted recordVideo --type=mp4 &lt;PATH TO VIDEO FILE&gt; booted —— 即是 simctl 当前选中的模拟器，如果当前有多个模拟器，那么选中的活动的 Simulator 为准。 5、Finder 和 Simulator 共享文件 现在，Simulator 具有 Finder 扩展，我们可以直接从 Finder 窗口共享文件给 Simulator 。 当然，如果你使用的是旧版本的 Xcode ，我们也可以使用 simctl 命令来进行类似操作： 1xcrun simctl addmedia booted &lt;PATH TO MEDIA FILE&gt; 这个功能太棒了，毕竟，我更喜欢通过拖拽来实现 Simulator 和 Finder 的文件共享。 6、 通过 Simulator 打开 URLs通过 simctl 也可以实现 Simulator 打开 URLs， 所以你也可以在旧的模拟器上打开自定义的 URL。 执行下面的 shell 命令 1xcrun simctl openurl booted &lt;URL&gt; Apple 官方文档 check out the documentation 7、快速打开 app 的文件系统 通过 simctl 你只需要简单的执行下面一句命令，你就能获取 app 的文件系统，但是，你得知道 bundle identifier： 1xcrun simctl get_app_container booted &lt;APPS BUNDLE ID&gt; 或者您可以通过 open 命令在 Finder 中快速打开目标文件夹： 1open `xcrun simctl get_app_container booted &lt;APPS BUNDLE ID&gt;` -a Finder 8、通过 Command 打开 Simulator 中的 APP有了 simctl ，你可以通过 Command 启动 Simulator 中的 app, 或者做一些环境变量的控制，这在自动化测试中是非常重要的。 你只要使用一下命令即可实现： 1xcrun simctl launch --console booted &lt;BUNDLE ID&gt; &lt;YOUR ARGUMENTS&gt; 9、 通过 Bundle ID 获取 app 的 info 信息 有时候，我们想获得 app 的 更多的信息，可以通过 simctl appinfo 获得以下格式的信息： 12345678910111213141516&#123; ApplicationType = User; Bundle = &lt;PATH TO APP FILE&gt;; BundleContainer = &lt;PATH TO FOLDER WITH APP FILE&gt;; CFBundleDisplayName = TestiOSApp; CFBundleExecutable = TestiOSApp; CFBundleIdentifier = \"com.ahmed.app.TestiOSApp\"; CFBundleName = TestiOSApp; CFBundleVersion = 1; DataContainer = &lt;PATH TO YOUR DATA&gt;; GroupContainers = &#123; &#125;; Path = &lt;PATH TO APP FILE&gt;; SBAppTags = ( );&#125; 执行以下命令你就能获取以上格式的信息： 1xcrun simctl appinfo booted &lt;BUNDLE ID&gt; 最后…… iOS Simulator 功能强大，是我们开发中必备的神器，当你掌握了它的相关细节以及使用技巧可以极大的提高你的开发效率。当然，作为一个有追求的 iOS 工程师，你更应该去挖掘它那些鲜为人知的功能，然后记得要告诉我哟😊！ 参考iOS Simulator on Steroids: Tips &amp; Tricks in Xcode 9 水平有限，如有疏漏，望指正欢迎交流，欢迎 star github遗人🌹，手有余香","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://cnkcq.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://cnkcq.github.io/tags/Swift/"}]},{"title":"UIKit 扩展系列之 UIView","slug":"UIKit 扩展系列之 UIView","date":"2017-08-13T02:48:13.000Z","updated":"2017-09-22T08:01:40.058Z","comments":true,"path":"2017/08/13/UIKit 扩展系列之 UIView/","link":"","permalink":"http://cnkcq.github.io/2017/08/13/UIKit 扩展系列之 UIView/","excerpt":"前言 对 iOS 熟悉的同学应该都知道，在开发的过程中，我们经常会创建一些扩展来封装一些常用的代码块以便我们快速开发，我也不例外，在开发的过程中我搜集了一些比较常用的代码片段放在github 仓库里，这里我要讲的是对 UIView 的一些扩展。","text":"前言 对 iOS 熟悉的同学应该都知道，在开发的过程中，我们经常会创建一些扩展来封装一些常用的代码块以便我们快速开发，我也不例外，在开发的过程中我搜集了一些比较常用的代码片段放在github 仓库里，这里我要讲的是对 UIView 的一些扩展。 正文 flatSubviews 想必大家有过这样的经历吧，有时候，我们需要对系统控件进行更改，当然也可能是对第三方控件进行修改，这个时候我们往往需要去遍历一个视图的所有子视图，当然这个时候大家可能首先会想到使用系统的 subviews 属性，但是，这只能得到当前视图的所有子视图，那么子视图的子视图呢？这里我为 UIView 扩展了一个属性 flatSubviews ，这个属性包含了视图的子视图以及子视图的子视图，其实实现方法并不难，这里主要使用到了迭代模式。下面我们来看看其中的内部实现： 1234567891011/// `self`'s all subviews include the subview's subviews. var flatSubviews: [UIView] &#123; var views: [UIView] = [] self.subviews.forEach &#123; (sub) in views.append(sub) if !sub.subviews.isEmpty &#123; views += sub.flatSubviews &#125; &#125; return views &#125; 看到这里大家是不是觉得其实很简单呢？☺ functions(1) 便捷的为 View 添加圆角 12345/// When positive, the background of the layer will be drawn with rounded corners. Also effects the mask generated by the`masksToBounds' property. Defaults to true. Animatable.func cornerRadius(_ radius: CGFloat) &#123; layer.cornerRadius = radius layer.masksToBounds = true&#125; (2) 快速添加点击手势 123456789101112/// Add tapGesture/action for particular event.////// - Parameters:/// - tapNumber: Default is 1. The number of taps required to match/// - target: `self`/// - action: a `Selector`func addTapGesture(_ tapNumber: Int = 1, target: Any = self, action: Selector) &#123; let tap = UITapGestureRecognizer(target: target, action: action) tap.numberOfTapsRequired = tapNumber isUserInteractionEnabled = true addGestureRecognizer(tap)&#125; (3) 截取视图 1234567891011/// Returns an image of the current view /// /// - Parameter scale: scale /// - Returns: A new image func getSnapshot(scale: CGFloat = 0) -&gt; UIImage &#123; UIGraphicsBeginImageContextWithOptions(bounds.size, false, scale) drawHierarchy(in: bounds, afterScreenUpdates: true) let image = UIGraphicsGetImageFromCurrentImageContext()! UIGraphicsEndImageContext() return image &#125; (4) 添加边线 为 View 添加边线也是一个高频的需求，我们会经常遇到为 UITextField 或者 自定义的 Cell 添加下边线。通常情况下，我们会想到使用贝塞尔曲线，我开始也是这样用的，后来发现在适配横竖屏的时候比较麻烦，如果你比较好的实现方式，希望你能告诉我。后来还是决定 使用 UIView 自定义 Line ，然后用 AutoLayout 添加约束，这样就完美的适配了横竖屏了。 12345678910111213141516171819202122232425262728293031323334353637383940func addBorder(for edges: [UIRectEdge], width: CGFloat = 1, color: UIColor = .black, insets: UIEdgeInsets = UIEdgeInsets(all: 0)) &#123; var edgesValues: [UIRectEdge] = edges if edges.contains(.all) &#123; edgesValues = [.top, .bottom, .left, .right] &#125; let allSpecificBorders:[UIRectEdge] = [.top, .bottom, .left, .right] for edge in allSpecificBorders &#123; if let view = viewWithTag(Int(edge.rawValue)) &#123; view.removeFromSuperview() &#125; if edgesValues.contains(edge) &#123; let view = UIView() view.tag = Int(edge.rawValue) view.backgroundColor = color view.translatesAutoresizingMaskIntoConstraints = false addSubview(view) var horizontalVisualFormat = \"H:\" var verticalVisualFormat = \"V:\" switch edge &#123; case UIRectEdge.bottom: horizontalVisualFormat += \"|-(\\(insets.left))-[v]-(\\(insets.right))-|\" verticalVisualFormat += \"[v(\\(width))]-(\\(insets.bottom))-|\" case UIRectEdge.top: horizontalVisualFormat += \"|-(\\(insets.left))-[v]-(\\(insets.right))-|\" verticalVisualFormat += \"|-(\\(insets.top))-[v(\\(width))]\" case UIRectEdge.left: horizontalVisualFormat += \"|-(\\(insets.left))-[v(\\(width))]\" verticalVisualFormat += \"|-(\\(insets.top))-[v]-(\\(insets.bottom))-|\" case UIRectEdge.right: horizontalVisualFormat += \"[v(\\(width))]-(\\(insets.right))-|\" verticalVisualFormat += \"|-(\\(insets.left))-[v]-(\\(insets.right))-|\" default: break &#125; self.addConstraints(NSLayoutConstraint.constraints(withVisualFormat: horizontalVisualFormat, options: .directionLeadingToTrailing, metrics: nil, views: [\"v\": view])) self.addConstraints(NSLayoutConstraint.constraints(withVisualFormat: verticalVisualFormat, options: .directionLeadingToTrailing, metrics: nil, views: [\"v\": view])) &#125; &#125;&#125; 使用效果： UI 扩展，请看 UIKit.plus水平有限，如有疏漏，望指正欢迎交流，欢迎 star CNKCQ遗人🌹，手有余香 blog","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://cnkcq.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://cnkcq.github.io/tags/Swift/"}]},{"title":"完美适配，您需要知道的 SnapKit","slug":"完美适配，您需要知道的 SnapKit","date":"2017-08-12T09:48:13.000Z","updated":"2017-09-22T08:01:40.058Z","comments":true,"path":"2017/08/12/完美适配，您需要知道的 SnapKit/","link":"","permalink":"http://cnkcq.github.io/2017/08/12/完美适配，您需要知道的 SnapKit/","excerpt":"前言 众所周知，iPhone 的屏幕是越来越多样化了，多样化的屏幕满足了用户差异化的需求，同时也增加了开发者的工作 —– 适配，面对多样化、不同屏幕尺寸的设备，之前在 iOS 中的 frame 布局以显得不合时宜，于是 Apple 推出了 AutoLayout ，AutoLayout 在可是化编程中的优势是不容置喙的，然而对于习惯于 code 界面的朋友来说就不那么友好了，面对这样的问题，众多第三方框架横空出世，目前为止支持率比较高的当属 SnapKit 了。","text":"前言 众所周知，iPhone 的屏幕是越来越多样化了，多样化的屏幕满足了用户差异化的需求，同时也增加了开发者的工作 —– 适配，面对多样化、不同屏幕尺寸的设备，之前在 iOS 中的 frame 布局以显得不合时宜，于是 Apple 推出了 AutoLayout ，AutoLayout 在可是化编程中的优势是不容置喙的，然而对于习惯于 code 界面的朋友来说就不那么友好了，面对这样的问题，众多第三方框架横空出世，目前为止支持率比较高的当属 SnapKit 了。 正文 当然，如果你之前对 Masonry 非常熟悉，那么恭喜你，你可以平滑的过度到 SnapKit, 如果你对 SnapKit 比较陌生，那么也没关系，请继续往下看☺。 安装 如果你的项目是用 CocoaPods 来管理组件的，那么你只需要在 Podfile 里加入 ： 1pod 'SnapKit', '~&gt; 3.0' 然后在 terminal 里执行 1pod install 等待安装成功就可以 import SnapKit 使用了。 用法 SnapKit 框架的设计，简单易用，可读性好。当你想要构建一个 tableView , tableView 在父视图中的 padding 为 20, 那么用 SnapKit 怎么做呢？ 123456789101112131415161718192021tableView.snp.makeConstraints &#123; (make) in make .edges .equalTo(self.view) .inset(UIEdgeInsets( top: 20, left: 20, bottom: 20, right: 20 ) ) &#125;``` or ```swift tableView.snp.makeConstraints &#123; (make) in make.left.top.equalTo(self.view).offset(20) make.right.bottom.equalTo(self.view).offset(-20) &#125; 这是最常用的写法了，当然我们的实际项目中的布局是非常复杂的，并不是所有的视图都能用 equalTo 来进行布局的，有了 SnapKit ，你可以用： .equalTo 等价于 NSLayoutRelation.Equal.lessThanOrEqualTo 等价于 NSLayoutRelation.GreaterThanOrEqual.greaterThanOrEqualTo 等价于 NSLayoutRelation.GreaterThanOrEqual 我们用一张表来罗列出 SnapKit 的属性与 NSLayout 中的属性对应关系： ViewAttribute NSLayoutAttribute view.snp.left NSLayoutAttribute.left view.snp.right NSLayoutAttribute.right view.snp.top NSLayoutAttribute.top view.snp.bottom NSLayoutAttribute.bottom view.snp.leading NSLayoutAttribute.leading view.snp.trailing NSLayoutAttribute.trailing view.snp.width NSLayoutAttribute.width view.snp.height NSLayoutAttribute.height view.snp.centerX NSLayoutAttribute.centerX view.snp.centerY NSLayoutAttribute.centerY view.snp.lastBaseline NSLayoutAttribute.lastBaseline 通过这张表，我们可以根据自己的需要对相应的动画进行布局，但这还不能完全满足我们的需求，我们的应用是非常复杂的，如果产品要求我们的 APP 需要根据用户的交互反馈来更新视图的 frame 或者 需要做动画呢？别担心，SnapKit 为我们提供了 Constraint 属性关联。也就是说我们可以将要更改的约束进行关联，然后改变它，如：声明关联属性 1var topConstraint: Constraint? = nil 初始化 123456button.snp.makeConstraints &#123; (make) in self.topConstraint = make.top.equalTo(self.view).offset(100).constraint make.centerX.equalTo(self.view.snp.centerX) make.width.equalTo(60) make.height.equalTo(30) &#125; 更改 1234UIView.animate(withDuration: 5) &#123; self.topConstraint?.update(offset: 200) self.view.layoutIfNeeded() &#125; 这样一个简单的动画就完成了。当然，如果你想更新约束，你还可以用 .snp.updateConstraints 1234self.button.snp.updateConstraints(&#123; (make) in make.top.equalTo(200) &#125;) self.view.layoutIfNeeded() 还有一个问题是，如果我们引用了一个三方视图库，我们想改变他的约束，担忧不知道原来的约束怎么办呢？其实我们可以用 snp.remakeConstraints 123456button.snp.remakeConstraints &#123; (make) in make.top.equalTo(self.view).offset(100) make.centerX.equalTo(self.view.snp.centerX) make.width.equalTo(60) make.height.equalTo(30)&#125; 这样首先会移除原有的控件的约束，然后重新设置约束。看到这里相信大家对 SnapKit 的使用并不陌生了吧！ 这里有一个常见的问题， 如果我们需要通过数组动态创建一组控件，要求长宽高都相等，并列排放在父视图中： 123456789101112131415161718192021for (idx, item) in items.enumerated() &#123; if items.count &lt; 2 &#123; return &#125; if idx == 0 &#123; item.snp.makeConstraints(&#123; (make) in make.left.top.bottom.equalTo(self) make.width.equalTo(items[idx + 1]) make.right.equalTo(items[idx + 1].snp.left) &#125;) &#125; else if idx == items.count - 1 &#123; item.snp.makeConstraints(&#123; (make) in make.right.top.bottom.equalTo(self) make.width.equalTo(items[idx - 1]) &#125;) &#125; else &#123; item.snp.makeConstraints(&#123; (make) in make.top.bottom.equalTo(self) make.left.equalTo(items[idx - 1].snp.right) make.width.equalTo(items[idx - 1].snp.width) &#125;) &#125; &#125; 这样，一组动态的创建好了！请看 AutoLayoutDemo水平有限，如有疏漏，望指正欢迎交流，欢迎 star CNKCQ遗人🌹，手有余香 blog 参考snapKit","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://cnkcq.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://cnkcq.github.io/tags/Swift/"}]},{"title":"神奇，Swift 中竟然可以这样使用保留字!","slug":"神奇，Swift 中竟然可以这样使用保留字!","date":"2017-08-08T13:48:13.000Z","updated":"2017-09-22T08:01:40.058Z","comments":true,"path":"2017/08/08/神奇，Swift 中竟然可以这样使用保留字!/","link":"","permalink":"http://cnkcq.github.io/2017/08/08/神奇，Swift 中竟然可以这样使用保留字!/","excerpt":"前一段时间，记得我在写一个 enum 时，发现了一个有意思的事情，当我在定义 enum 时会习惯性的定义一个 default ，在 Swift 中这是编译不过的： 12345enum RefreshState &#123; case default case always case didLoad&#125;","text":"前一段时间，记得我在写一个 enum 时，发现了一个有意思的事情，当我在定义 enum 时会习惯性的定义一个 default ，在 Swift 中这是编译不过的： 12345enum RefreshState &#123; case default case always case didLoad&#125; 比如说这样写就会报 error :Keyword ‘default’ cannot be used as an identifier here我们可以看到 keyword 是不能用作 identifier 的，编译器在报这个 error 时，大家一定会注意到可以通过 fix 来避免这样的问题： 12345enum RefreshState &#123; case `default` case always case didLoad&#125; 这样就没有任何 warning 或者 error 了同理，我们在声明变量的时候也可以这样做： 1var class: String! to 1var `class`: String! 这样看来，当我们在使用到 keyword 的时候也就不必为了避开它委屈求全了。在 OC 中大家为了避免循环引用会经常用到 weakSelf and strongSelf，那么 RAC 中提供了 @weakify(self) and @strongify(self), 这个实现是非常优雅的。然而在 Swift 中，我想大家对这样的写法并不陌生吧： 123456789DispatchQueue.main.async &#123; [weak self] in guard let strongSelf = self else &#123; return &#125; strongSelf.label.frame = CGRect(x: 40, y: 200, width: 40, height: 40) strongSelf.label.backgroundColor = .blue strongSelf.label.text = \"hello\" strongSelf.label.font = UIFont.systemFont(ofSize: UIFont.systemFontSize) &#125; 对于这段代码，我们有什么需要优化的呢？鉴于上面所讲的我们也可以这样： 12345678910DispatchQueue.main.async &#123; [weak self] in guard let `self` = self else &#123; return &#125; self.label.frame = CGRect(x: 40, y: 200, width: 40, height: 40) self.label.backgroundColor = .blue self.label.text = \"hello\" self.label.font = UIFont.systemFont(ofSize: UIFont.systemFontSize) &#125; 我更倾向与这样魔性的写法，你觉得呢？ 水平有限，如有疏漏，望指正欢迎交流，欢迎 star github遗人🌹，手有余香","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://cnkcq.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://cnkcq.github.io/tags/Swift/"}]},{"title":"动手创建私有 CocoaPods","slug":"动手创建私有 CocoaPods","date":"2017-06-10T08:08:12.000Z","updated":"2017-09-22T08:01:40.058Z","comments":true,"path":"2017/06/10/动手创建私有 CocoaPods/","link":"","permalink":"http://cnkcq.github.io/2017/06/10/动手创建私有 CocoaPods/","excerpt":"","text":"前言最近在分离公司的业务库，所以用到了 private cocoapods，在此记录下所遇到的坑","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://cnkcq.github.io/tags/iOS/"},{"name":"App","slug":"App","permalink":"http://cnkcq.github.io/tags/App/"},{"name":"Update","slug":"Update","permalink":"http://cnkcq.github.io/tags/Update/"}]},{"title":"iOS客户端升级提醒策略","slug":"iOS客户端升级提醒策略","date":"2017-05-10T09:08:12.000Z","updated":"2017-09-22T08:01:40.058Z","comments":true,"path":"2017/05/10/iOS客户端升级提醒策略/","link":"","permalink":"http://cnkcq.github.io/2017/05/10/iOS客户端升级提醒策略/","excerpt":"前言作为一个iOS开发者，对于iOS客户如何提醒用户升级是一个不可回避的问题，也许你会说这是产品汪应该考虑的事情，其实也不完全是，万一产品汪没有考虑到呢？😜这种情况下你是不是可以拿出来和他撕一撕。","text":"前言作为一个iOS开发者，对于iOS客户如何提醒用户升级是一个不可回避的问题，也许你会说这是产品汪应该考虑的事情，其实也不完全是，万一产品汪没有考虑到呢？😜这种情况下你是不是可以拿出来和他撕一撕。 提醒策略1. App Store 提醒其实 App Store 提醒是每一款 App 都具有的功能，我们无需做额外的操作，有苹果应用商店自动检测提示，我们需要注意的是写好产品更新文案即可。 2. 远程推送提醒当我们有新的版本发布的时候，我们可以通过后台服务器推送去通知用户更新客户端。 优点： 新版本一发布我们就可以通知到用户哪怕他并没有打开过我们的应用 缺点： 如果用户通过其他途径已经更新了，这种情况下还是会受到通知，这无疑为用户增加了干扰。 如果用户关闭了推送通知，那么服务器即使推送了更新，用户也不会受到更新提示 3. App 内部弹框提醒App 内部弹框更新提醒，这是目前应用得非常广泛的一种更新提醒方式，其中有弱更强更之分。 在 App 只做了一些小的修改的时候，我们就没有必要强制用户更新，如果我们出现了重大改版或者其他因素导致老旧的 App 无法正常使用，这种情况下，我们需要强制用户更新 App。那么问题来了，我们如何控制什么时候强更，什么时候弱更呢？这就需要后台服务器的兄弟配合了，我们的后台兄弟需要为我们提供一个接口，这个接口里包含我们所需要的强弱更判断，以及版本判断，这样我们就可以灵活的进行强弱更以及版本判断了","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://cnkcq.github.io/tags/iOS/"},{"name":"App","slug":"App","permalink":"http://cnkcq.github.io/tags/App/"},{"name":"Update","slug":"Update","permalink":"http://cnkcq.github.io/tags/Update/"}]},{"title":"iOS10上传AppStore所遇到的坑","slug":"iOS10上传AppStore所遇到的坑","date":"2016-09-25T09:58:12.000Z","updated":"2017-09-22T08:01:40.058Z","comments":true,"path":"2016/09/25/iOS10上传AppStore所遇到的坑/","link":"","permalink":"http://cnkcq.github.io/2016/09/25/iOS10上传AppStore所遇到的坑/","excerpt":"苹果的反馈邮件：Dear developer,We have discovered one or more issues with your recent delivery for “城满财富”. To process your delivery, the following issues must be corrected:","text":"苹果的反馈邮件：Dear developer,We have discovered one or more issues with your recent delivery for “城满财富”. To process your delivery, the following issues must be corrected:This app attempts to access privacy-sensitive data without a usage description. The app’s Info.plist must contain an NSContactsUsageDescription key with a string value explaining to the user how the app uses this data.This app attempts to access privacy-sensitive data without a usage description. The app’s Info.plist must contain an NSCalendarsUsageDescription key with a string value explaining to the user how the app uses this data.This app attempts to access privacy-sensitive data without a usage description. The app’s Info.plist must contain an NSPhotoLibraryUsageDescription key with a string value explaining to the user how the app uses this data.This app attempts to access privacy-sensitive data without a usage description. The app’s Info.plist must contain an NSBluetoothPeripheralUsageDescription key with a string value explaining to the user how the app uses this data.This app attempts to access privacy-sensitive data without a usage description. The app’s Info.plist must contain an NSMicrophoneUsageDescription key with a string value explaining to the user how the app uses this data.This app attempts to access privacy-sensitive data without a usage description. The app’s Info.plist must contain an NSCameraUsageDescription key with a string value explaining to the user how the app uses this data.This app attempts to access privacy-sensitive data without a usage description. The app’s Info.plist must contain an NSMotionUsageDescription key with a string value explaining to the user how the app uses this data.Though you are not required to fix the following issues, we wanted to make you aware of them:Missing Push Notification Entitlement - Your app includes an API for Apple’s Push Notification service, but the aps-environment entitlement is missing from the app’s signature. To resolve this, make sure your App ID is enabled for push notification in the Provisioning Portal. Then, sign your app with a distribution provisioning profile that includes the aps-environment entitlement. This will create the correct signature, and you can resubmit your app. See “Provisioning and Development” in the Local and Push Notification Programming Guide for more information. If your app does not use the Apple Push Notification service, no action is required. You may remove the API from future submissions to stop this warning. If you use a third-party framework, you may need to contact the developer for information on removing the API.Once the required corrections have been made, you can then redeliver the corrected binary.Regards,The App Store team 看一下苹果的官方描述：You must statically declare your app’s intended use of protected data classes by including the appropriate purpose string keys in your Info.plist file. For example, you must include the NSCalendarsUsageDescription key to access the user’s Calendar data. If you don’t include the relevant purpose string keys, your app exits when it tries to access the data.解决方案：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!-- 🖼 Photo Library --&gt;&lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt;&lt;string&gt;请点击“允许”以允许访问&lt;/string&gt;&lt;!-- 📷 Camera --&gt;&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;&lt;string&gt;&lt;/string&gt;&lt;!-- 🎤 Microphone --&gt;&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;&lt;string&gt;&lt;/string&gt;&lt;!-- 📍 Location --&gt;&lt;key&gt;NSLocationUsageDescription&lt;/key&gt;&lt;string&gt;&lt;/string&gt;&lt;!-- 📍 Location When In Use --&gt;&lt;key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt;&lt;string&gt;&lt;/string&gt;&lt;!-- 📍 Location Always --&gt;&lt;key&gt;NSLocationAlwaysUsageDescription&lt;/key&gt;&lt;string&gt;&lt;/string&gt;&lt;!-- 📆 Calendars --&gt;&lt;key&gt;NSCalendarsUsageDescription&lt;/key&gt;&lt;string&gt;&lt;/string&gt;&lt;!-- ⏰ Reminders --&gt;&lt;key&gt;NSRemindersUsageDescription&lt;/key&gt;&lt;string&gt;&lt;/string&gt;&lt;!-- 🏊 Motion --&gt;&lt;key&gt;NSMotionUsageDescription&lt;/key&gt;&lt;string&gt;&lt;/string&gt;&lt;!-- 💊 Health Update --&gt;&lt;key&gt;NSHealthUpdateUsageDescription&lt;/key&gt;&lt;string&gt;&lt;/string&gt;&lt;!-- 💊 Health Share --&gt;&lt;key&gt;NSHealthShareUsageDescription&lt;/key&gt;&lt;string&gt;&lt;/string&gt;&lt;!-- ᛒ🔵 Bluetooth Peripheral --&gt;&lt;key&gt;NSBluetoothPeripheralUsageDescription&lt;/key&gt;&lt;string&gt;&lt;/string&gt;&lt;!-- 🎵 Media Library --&gt;&lt;key&gt;NSAppleMusicUsageDescription&lt;/key&gt;&lt;string&gt;&lt;/string&gt; 之间的描述一定要填写","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://cnkcq.github.io/tags/iOS/"},{"name":"博客","slug":"博客","permalink":"http://cnkcq.github.io/tags/博客/"}]},{"title":"RxSwift -- 项目实战","slug":"RxSwift项目实战","date":"2016-09-20T09:58:12.000Z","updated":"2017-09-22T08:01:40.058Z","comments":true,"path":"2016/09/20/RxSwift项目实战/","link":"","permalink":"http://cnkcq.github.io/2016/09/20/RxSwift项目实战/","excerpt":"前言RxSwift 源自ReactiveX，它蕴含了深刻的FRP思想，这是一个崭新的世界，我也是慕名而来，本着好学的心态，叩开RxSwift的大门，来了之后才发现，这里人迹罕至，路上满是泥泞，坑坑洼洼，幸好遇到了RxExample, 从此便奉为圭皋，仔细研读，跟随者开拓者的足迹，我也进行了一次RxSwift之旅，其中酸甜苦辣，请亲自品尝。 装备装备的选择对你趟坑过河的影响还是蛮大的，选好内裤，走起路来便可以雄赳赳气昂昂。 我选择的内裤便是 Moya、Alamofire、ObjectMapper 等，有了这些内裤，你便可以优雅的踩坑。","text":"前言RxSwift 源自ReactiveX，它蕴含了深刻的FRP思想，这是一个崭新的世界，我也是慕名而来，本着好学的心态，叩开RxSwift的大门，来了之后才发现，这里人迹罕至，路上满是泥泞，坑坑洼洼，幸好遇到了RxExample, 从此便奉为圭皋，仔细研读，跟随者开拓者的足迹，我也进行了一次RxSwift之旅，其中酸甜苦辣，请亲自品尝。 装备装备的选择对你趟坑过河的影响还是蛮大的，选好内裤，走起路来便可以雄赳赳气昂昂。 我选择的内裤便是 Moya、Alamofire、ObjectMapper 等，有了这些内裤，你便可以优雅的踩坑。 出发作为一个swifter Alamofire 对你来说并不陌生，它的优雅与简洁没有多少库能出其左右，然而对于 Moya 你可能未必熟悉，不过你不熟悉也没关系，协议和扩展造就了他的优雅与平易近人，你可以轻松的用它来封装你的网络请求层，他与Alamofire 也是不离不弃.如果想获取信息，那么你需这样做：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869enum OSCIOService &#123; case NewsList, NewBanner, TweetList, BlogList, EventList, EventBanner case Login(username: String, password: String) case FindUser(name: String) case Search(content: String)&#125;extension OSCIOService: TargetType &#123; var baseURL: NSURL &#123;// return NSURL(string: \"http://www.oschina.net/action/api\")! //XML格式 return NSURL(string: \"http://www.oschina.net/action/apiv2\")! //JSON格式 &#125; var path: String &#123; switch self &#123; case .NewsList: return \"/news\" case .NewBanner: return \"/banner\" case .TweetList: return \"/tweet_list\" case .BlogList: return \"/blog_list\" case .EventList: return \"/event_list\" case .EventBanner: return \"/banner\" case .Login( _, _): return \"/login_validate\" case .FindUser(_): return \"/find_user\" case .Search(_): return \"/search_list\" &#125; &#125; var method: Moya.Method &#123; switch self &#123; case .Login: return .POST default: return .GET &#125; &#125; var parameters: [String: AnyObject]? &#123; switch self &#123; case .Login(let username, let password): return [\"username\": username, \"pwd\": password] case .NewBanner: return [\"catalog\": 1] case .EventBanner: return [\"catalog\": 3] case .FindUser(let name): return [\"name\":name] default: return nil &#125; &#125; var sampleData: NSData &#123; return \"&#123;&#125;\".dataUsingEncoding(NSUTF8StringEncoding)! // for test &#125; var multipartBody: [MultipartFormData]? &#123; return nil &#125;&#125; 这样就可以封装好你的API了既然我们来到的FRP的路上，那么我们应该也改改以前惯用的MVC了，MVVM 才是更优雅的姿势，那个问题来了，我们的viewModel 呢？别着急，请看下面：123456789101112131415161718192021222324252627class NewsViewModel &#123; var provider: RxMoyaProvider&lt;OSCIOService&gt; var backgroundScheduler: OperationQueueScheduler! init() &#123; let operationQueue = NSOperationQueue() backgroundScheduler = OperationQueueScheduler(operationQueue: operationQueue) self.provider = RxMoyaProvider&lt;OSCIOService&gt;() &#125; func fetch() -&gt; Observable&lt;[NewsItem]?&gt; &#123; return Observable.create(&#123; observer -&gt; Disposable in self.provider.request(OSCIOService.NewsList) &#123; response in switch response &#123; case let .Success(response): let result = Mapper&lt;NewsRootClass&gt;().map(String(data: response.data, encoding: NSUTF8StringEncoding)) observer.on(Event.Next(result?.result?.items)) case let .Failure(error): observer.on(Event.Error(error)) &#125; observer.onCompleted() &#125; return NopDisposable.instance &#125;) &#125;&#125; 在viewModel中我提供了一个网络 Observable 以供外部订阅，将数据转化为可以订阅的Stream那么这样我们就可以到 Controller 进行数据订阅了：123456789101112131415let viewModel = NewsViewModel() viewModel.fetch().subscribe( onNext: &#123; entities in if let result = entities &#123; self.newsItems = result &#125; log.info(\"你好\") &#125;, onError: &#123; error in log.error(\"\\(error)\") &#125;, onCompleted: &#123; log.info(\"completed\") &#125;, onDisposed: &#123; log.info(\"disposed\") &#125;).addDisposableTo(self.disposeBag) 当我们拿到了数据，我们就可以进行数据展示了，这与我们常规的数据展示不无差别好了，由于文字功底有限，我就不赘述了 完整项目可移步：https://github.com/CNKCQ 相关资料：https://mcxiaoke.gitbooks.io/rxdocs/content/https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.mdhttp://cocoadocs.org/docsets/RxCocoa/1.5/index.htmlhttps://coderwall.com/p/vti_8w/rxswift-learning-resourceshttps://leon_lizi.gitbooks.io/rx-/content/observableyu_alamofire.htmlhttp://www.oschina.net/openapi/docs/","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://cnkcq.github.io/tags/iOS/"},{"name":"博客","slug":"博客","permalink":"http://cnkcq.github.io/tags/博客/"}]},{"title":"iOS设计编码规范","slug":"iOS设计编码规范","date":"2016-07-25T09:50:12.000Z","updated":"2017-09-22T08:01:40.058Z","comments":true,"path":"2016/07/25/iOS设计编码规范/","link":"","permalink":"http://cnkcq.github.io/2016/07/25/iOS设计编码规范/","excerpt":"1, iOS 常用系统控件1.0.1 Status Bar 状态栏状态栏的信息内容有两种不同的风格：暗色（黑）和亮色（白）: 1.0.2 Navigation Bar 导航栏导航栏总在屏幕的顶部，状态栏的正下方。默认的，导航栏背景会进行轻微半透明处理，以及对下面的内容进行毛玻璃般的模糊处理:","text":"1, iOS 常用系统控件1.0.1 Status Bar 状态栏状态栏的信息内容有两种不同的风格：暗色（黑）和亮色（白）: 1.0.2 Navigation Bar 导航栏导航栏总在屏幕的顶部，状态栏的正下方。默认的，导航栏背景会进行轻微半透明处理，以及对下面的内容进行毛玻璃般的模糊处理: 1.0.3 Tab Bar 标签栏标签栏在屏幕底部。默认情况下背景使用和导航栏一样的轻微半透明效果，以及使用和系统一样的模糊处理下面遮住的内容。: 1.0.4 Table View 表格视图表格视图用于呈现大多数列表风格的信息，可以一列或者多列，也可以选择几行来划分信息或分组。纯表格:分组表格(头部和尾部字体：13pt):默认:系统自带cell 默认中高度 44pt 带副标题:带数值:表格视图每一行cell选中自带高亮 1.0.5 Alerts 警告提醒警告提醒用于通知用户关键信息，以及可以强制用户做出一些动作选择。警告视图总包含一个标题文本，可以不限于一行（对于纯信息警告如“OK”），以及不限一个或两个按钮（请求式的决定，如“发送”和“取消”）。: 1.0.6 Actions Sheets 动作菜单用于从可执行的动作中选择执行一个动作，要求App用户选择一个动作继续，或者取消。: 1.0.7 Switch 开关用于从可执行的动作中选择执行一个动作，要求App用户选择一个动作继续，或者取消。: 1.0.8 Search Bar 搜索栏搜索栏默认有两种风格：凸显（Prominent）和最小（Minimal）风格。两种风格的功能都相同。:（无提示栏、有提示栏）（最小风格的搜索栏） 1.0.9 Edit menu 编辑菜单在一个元素被选定时(文本，图片及其他)，编辑菜单允许用户执行复制、粘贴、剪切等操作: 1.1.1 Edit menu 浮动窗当要求用户在程序进行的同时输入多个信息时，浮动框（Popover）是个绝佳选择: 1.1.2 Segment Controls 分段控件分段控件包含一系列分段（至少两个），可以用于筛选内容或为整理的分类内容创建标签: 1.1.3 Sliders 滑块滑块控件可以让用户从一个允许范围内滑动滑块选择一个特定的值: 1.1.4 Stepper 进步器一个步进器需要包含两个分段按钮，一个用于减少当前值，一个用于增加。: 1.1.5 Picker 选择器选择器通常用作级联表达，常见的时间选择器: 1.1.6 Activity dialog 活动对话框活动对话框用于内容（text, images, links）分享: 1.1.7 Collection View 网格视图通常用于网格布局（九宫格，瀑布流）:Collection默认选中没有高亮 1.1.8 Toolbar 工具栏当遇到多种操作可以考虑使用工具栏: 1.0.8 System icons 系统icon系统图标往往有特定的意向表达，被用户熟知，适当的应用系统图标会降低app的使用难度, 提高用户体验: 2, iOS 常用配色方案2.0.1 iOS 系统默认颜色 Name hex groupTableViewBackgroundColor #EFEFF4 lightTextColor #FFFFFF darkTextColor #000000 blackColor #000000 darkGrayColor #555555 lightGrayColor #AAAAAA grayColor #7F7F7F whiteColor #FFFFFF redColor #FF0000 greenColor #00FF00 blueColor #0000FF cyanColor #00FFFF yellowColor #FFFF00 magentaColor #FF00FF orangeColor #FF7F00 purpleColor #7F007F brownColor #996633 clearColor #000000 2.0.2 iOS 苹果官方设计指南推荐常用颜色 2.0.3 iOS 推荐配色 3, iOS 常用系统字体 Element Size(pt) Weight Spacing(pt) Type systemFont 14 default default Text smallSystemFont 12 default default Text buttonFont 18 default default Text labelFont 17 default default Text Nav Bar Title 17 Medium 0.5 Display Nav Bar Button 17 Regular 0.5 Display Search Bar 13.5 Regular 0 Text Tab Bar Button 10 Regular 0.1 Text Table Header 12.5 Regular 0.25 Text Table Row 16.5 Regular 0 Text Table Row Subtitle 12 Regular 0 Text Table Footer 12.5 Regular 0.2 Text Action Sheets 20 Regular / Medium 0.5 Display https://developer.apple.com/ios/human-interface-guidelines iOS官方设计指南 http://www.ui.cn/detail/32167.html 中文 http://ivomynttinen.com/blog/ios-design-guidelines 英文 http://ms.csdn.net/geek/72062 全新Apple iOS设计规范指南 http://wiki.jikexueyuan.com/project/ios-9-human-computer-interface-guidelines/ iOS 9 人机交互指南 https://designcode.io/iosdesign-guidelines","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://cnkcq.github.io/tags/iOS/"},{"name":"博客","slug":"博客","permalink":"http://cnkcq.github.io/tags/博客/"}]},{"title":"Write once Run on iOS/Android","slug":"ReactNative实现跨平台开发","date":"2016-06-21T09:48:13.000Z","updated":"2017-09-22T08:01:40.058Z","comments":true,"path":"2016/06/21/ReactNative实现跨平台开发/","link":"","permalink":"http://cnkcq.github.io/2016/06/21/ReactNative实现跨平台开发/","excerpt":"一、应用场景 我们谁都不想重复造轮子，我们都希望write once run anywhere，react native 现在给你这个机会 先上图：","text":"一、应用场景 我们谁都不想重复造轮子，我们都希望write once run anywhere，react native 现在给你这个机会 先上图： 二、简单用例 1、简单实现一个历史记录的界面 在这里我就不谈环境部署了，按着官方文档一步一步来就可以了 初始化完项目后，我们可以在主目录里面看到Android和iOS的工程以及JS入口文件index.android.js和index.ios.js 我把这两个文件里面的类容都改为 1require('./App/app'); 这样我们就直接可以在app.js文件里写代码应用到Android和iOS中了 app.js里的代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/** * Sample React Native App * https://github.com/facebook/react-native */import React, &#123; AppRegistry, Platform, Component, TouchableOpacity, StyleSheet, Navigator, View, Text&#125; from 'react-native';import Home from './home';const defaultRoute = &#123; component: Home&#125;;class StartReact extends Component &#123; _renderScene(route, navigator) &#123; let Component = route.component; return ( &lt;Component &#123;...route.params&#125; navigator=&#123;navigator&#125; /&gt; ); &#125; _renderNavBar() &#123; const styles = &#123; title: &#123; flex: 1, alignItems: 'center', justifyContent: 'center' &#125;, button: &#123; flex: 1, width: 50, alignItems: 'center', justifyContent: 'center' &#125;, buttonText: &#123; fontSize: 18, color: '#FFFFFF', fontWeight: '400' &#125; &#125; var routeMapper = &#123; LeftButton(route, navigator, index, navState) &#123; if(index &gt; 0) &#123; return ( &lt;TouchableOpacity onPress=&#123;() =&gt; navigator.pop()&#125; style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;Back&lt;/Text&gt; &lt;/TouchableOpacity&gt; ); &#125; else &#123; return ( &lt;TouchableOpacity onPress=&#123;() =&gt; navigator.pop()&#125; style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;返回&lt;/Text&gt; &lt;/TouchableOpacity&gt; ); &#125; &#125;, RightButton(route, navigator, index, navState) &#123; if(index &gt; 0 &amp;&amp; route.rightButton) &#123; return ( &lt;TouchableOpacity onPress=&#123;() =&gt; navigator.pop()&#125; style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;下一页&lt;/Text&gt; &lt;/TouchableOpacity&gt; ); &#125; else &#123; return ( &lt;TouchableOpacity onPress=&#123;() =&gt; navigator.pop()&#125; style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;走你&lt;/Text&gt; &lt;/TouchableOpacity&gt; ); &#125; &#125;, Title(route, navigator, index, navState) &#123; return ( &lt;View style=&#123;styles.title&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;&#123;route.title ? route.title : '主页'&#125;&lt;/Text&gt; &lt;/View&gt; ); &#125; &#125;; return ( &lt;Navigator.NavigationBar style=&#123;&#123; alignItems: 'center', backgroundColor: '#fd9526', shadowOffset:&#123; width: 1, height: 0.5, &#125;, shadowColor: '#55ACEE', shadowOpacity: 0.8, &#125;&#125; routeMapper=&#123;routeMapper&#125; /&gt; ); &#125; render() &#123; return ( &lt;Navigator initialRoute=&#123;defaultRoute&#125; renderScene=&#123;this._renderScene&#125; sceneStyle=&#123;&#123;paddingTop: (Platform.OS === 'android' ? 64 : 44)&#125;&#125; navigationBar=&#123;this._renderNavBar()&#125; /&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5FCFF', &#125;, welcome: &#123; fontSize: 20, textAlign: 'center', margin: 10, &#125;, instructions: &#123; textAlign: 'center', color: '#333333', marginBottom: 5, &#125;,&#125;);AppRegistry.registerComponent('StartReact', () =&gt; StartReact); 当然这里还依赖了home.js，Navigation.js这里就不一一罗列了","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://cnkcq.github.io/tags/iOS/"},{"name":"react native","slug":"react-native","permalink":"http://cnkcq.github.io/tags/react-native/"},{"name":"Android","slug":"Android","permalink":"http://cnkcq.github.io/tags/Android/"}]},{"title":"纯代码实现UISplitViewController分屏效果","slug":"纯代码实现UISplitViewController分屏效果","date":"2016-05-20T09:48:13.000Z","updated":"2017-09-22T08:01:40.058Z","comments":true,"path":"2016/05/20/纯代码实现UISplitViewController分屏效果/","link":"","permalink":"http://cnkcq.github.io/2016/05/20/纯代码实现UISplitViewController分屏效果/","excerpt":"一、应用场景 UISplitViewController 是 iphone 6s plus,ipad系列常用的控件 在iOS8以上的iPhone中得到支持（ In iOS 8 and later）一个典型的场景：iPhone 6s plus 内置的设置APP; 根据苹果设计指南，UISplitViewController一般作为更控制器来使用即rootViewController（. Split view controllers are normally installed at the root of your app’s window），不能作为navigationController的子控制器。","text":"一、应用场景 UISplitViewController 是 iphone 6s plus,ipad系列常用的控件 在iOS8以上的iPhone中得到支持（ In iOS 8 and later）一个典型的场景：iPhone 6s plus 内置的设置APP; 根据苹果设计指南，UISplitViewController一般作为更控制器来使用即rootViewController（. Split view controllers are normally installed at the root of your app’s window），不能作为navigationController的子控制器。 二、简单用例 1、注册为根控制器，为splitViewController指定master-detail控制器 1234567let masterController: MasterController = MasterController() masterNav.addChildViewController(masterController) let detailController = DetailController() detailNav.addChildViewController(detailController) splitViewController.viewControllers = [masterNav,detailNav]; preferredDisplayMode = .Automatic window?.rootViewController = SplitController() 其中，viewControllers[0]为master viewControllers[1]为detail 本例中master为TableViewController 2、cell事件的响应，判断横竖屏，实现spliViewController的转场方法 123456let dest = DetailController()if UIScreen.mainScreen().bounds.width &gt; UIScreen.mainScreen().bounds.height &#123; self.showDetailViewController(dest, sender: names[indexPath.row])&#125; else &#123; self.showViewController(dest, sender: names[indexPath.row])&#125; 需要提醒一下的是，为了在dest中接收到的sender数据，dest必须实现split view controller的代理方法 1234func splitViewController(splitViewController: UISplitViewController, showDetailViewController vc: UIViewController, sender: AnyObject?) -&gt; Bool &#123; title = \"\\(sender!)\" return true&#125; 这样就简单实现了分屏效果 实例代码: SplitViewController","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://cnkcq.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://cnkcq.github.io/tags/Swift/"},{"name":"UISplitViewController","slug":"UISplitViewController","permalink":"http://cnkcq.github.io/tags/UISplitViewController/"},{"name":"分屏","slug":"分屏","permalink":"http://cnkcq.github.io/tags/分屏/"}]},{"title":"iOS安全问题之加密解密","slug":"iOS安全问题之加密解密","date":"2016-02-05T09:48:13.000Z","updated":"2017-09-22T08:01:40.058Z","comments":true,"path":"2016/02/05/iOS安全问题之加密解密/","link":"","permalink":"http://cnkcq.github.io/2016/02/05/iOS安全问题之加密解密/","excerpt":"一、应用场景 越来越多的应用和金钱都要打交道，用户隐私安全的保护也变得空前的重要了，互联网金融应用、电商应用支付、网络存储、数据网络传输……都需要对数据进行保护。","text":"一、应用场景 越来越多的应用和金钱都要打交道，用户隐私安全的保护也变得空前的重要了，互联网金融应用、电商应用支付、网络存储、数据网络传输……都需要对数据进行保护。 二、加密解密解决方案 既然数据安全如此重要，那么解决思路呢？ 1、对数据内容加密（通常在传输过程中） 2、对数据文件进行加密（通常用于本地数据库文件） 三、SQLCipher加密数据库文件 SQLCipher是完全开源的，代码可以在github上面找到。 我们可以通过Pod引进sqlcipher依赖 12pod 'FMDB', '~&gt; 2.6'pod 'SQLCipher', '~&gt; 3.3.1' 然后，在项目中添加相应的头文件，重写- (BOOL)open 方法： 12345678910111213141516171819202122- (BOOL)open &#123; if (_db) &#123; return YES; &#125; int err = sqlite3_open([self sqlitePath], &amp;_db ); if(err != SQLITE_OK) &#123; NSLog(@\"error opening!: %d\", err); return NO; &#125; else&#123; //数据库open后设置加密key [self setKey:@\"abc123\"]; &#125; if (_maxBusyRetryTimeInterval &gt; 0.0) &#123; // set the handler [self setMaxBusyRetryTimeInterval:_maxBusyRetryTimeInterval]; &#125; return YES;&#125; 好啦，至此，数据库文件加密已经完成！ 四、对数据内容加密 1、MD5系列不可逆加密 2、DES对称加密 3、AES对称加密 4、RSA非对称加密 5、ECC椭圆形加密 这5种方法加密安全系数从上到下依次递增。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://cnkcq.github.io/tags/iOS/"},{"name":"RSA","slug":"RSA","permalink":"http://cnkcq.github.io/tags/RSA/"},{"name":"AES","slug":"AES","permalink":"http://cnkcq.github.io/tags/AES/"},{"name":"MD5","slug":"MD5","permalink":"http://cnkcq.github.io/tags/MD5/"},{"name":"SQLCipher","slug":"SQLCipher","permalink":"http://cnkcq.github.io/tags/SQLCipher/"},{"name":"加密解密","slug":"加密解密","permalink":"http://cnkcq.github.io/tags/加密解密/"}]},{"title":"Xcode 7 升级问题","slug":"Xcode 7 升级问题","date":"2015-09-29T21:58:11.000Z","updated":"2017-09-22T08:01:40.058Z","comments":true,"path":"2015/09/29/Xcode 7 升级问题/","link":"","permalink":"http://cnkcq.github.io/2015/09/29/Xcode 7 升级问题/","excerpt":"","text":"最近用XCode 7 也有一段时间了，每次IDE升级都会产生一系列的问题，因此，小计一下，希望朋友们在遇到这些问题时能轻松应对。问题一：解决办法： 问题二：iOS模拟器出现一大堆UUID，特别的烦人。以下是解决这个恼人问题的方法，希望能帮到大家： 关闭Xcode 和 模拟器； $ sudo killall -9 com.apple.CoreSimulator.CoreSimulatorService $ rm -rf ~/Library/Developer/CoreSimulator/Devices 重启Xcode 问题就这么愉快的解决了。 顺便向大家推荐 Xcode 下本人使用频率较高的几款插件： 1，alcatrazPackage manager for Xcodehttp://alcatraz.iohttps://github.com/supermarin/Alcatrazxcode插件管理工具2，VVDocumenter-Xcode3，KSImageNamed-Xcode大家可以用alcatraz搜索自己喜欢的插件","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://cnkcq.github.io/tags/iOS/"},{"name":"Xcode","slug":"Xcode","permalink":"http://cnkcq.github.io/tags/Xcode/"},{"name":"BitCode","slug":"BitCode","permalink":"http://cnkcq.github.io/tags/BitCode/"}]},{"title":"学历是铜牌，能力是银牌，人脉是金牌，思维是王牌","slug":"学历是铜牌，能力是银牌，人脉是金牌，思维是王牌","date":"2015-08-29T21:58:11.000Z","updated":"2017-09-22T08:01:40.058Z","comments":true,"path":"2015/08/29/学历是铜牌，能力是银牌，人脉是金牌，思维是王牌/","link":"","permalink":"http://cnkcq.github.io/2015/08/29/学历是铜牌，能力是银牌，人脉是金牌，思维是王牌/","excerpt":"有人工作，有人上学，大家千万不要错过这篇文章，能看到这篇文章也是一种幸运，真的受益匪浅，对我有很大启迪，这篇文章将会改变你我的一生，真的太好了，希望与有缘人分享，也希望对有缘人有所帮助！看完之后有种“相见恨晚”的感觉，特别激动，希望大家好好的珍藏这篇文章，相信多年以后，再来看这篇文章，一定有不同的感觉。 正如”打工皇帝”唐骏说：”我觉得有两种人不要跟别人争利益和价值回报。第一种人就是刚刚进入企业的人，头5年千万不要说你能不能多给我一点儿工资，最重要的是能在企业里学到什么，对发展是不是有利……” 人总是从平坦中获得的教益少，从磨难中获得的教益多；从平坦中获得的教益浅，从磨难中获得的教益深。一个人在年轻时经历磨难，如能正确视之，冲出黑暗，那就是一个值得敬慕的人。最要紧的是先练好内功，毕业后这5年就是练内功的最佳时期，练好内功，才有可能在未来攀得更高。 出路在哪里？出路在于思路！ 其实，没有钱、没有经验、没有阅历、没有社会关系，这些都不可怕。没有钱，可以通过辛勤劳动去赚；没有经验，可以通过实践操作去总结；没有阅历，可以一步一步去积累；没有社会关系，可以一点一点去编织。但是，没有梦想、没有思路才是最可怕的，才让人感到恐惧，很想逃避! 人必须有一个正确的方向。无论你多么意气风发，无论你是多么足智多谋，无论你花费了多大的心血，如果没有一个明确的方向，就会过得很茫然，渐渐就丧失了斗志，忘却了最初的梦想，就会走上弯路甚至不归路，枉费了自己的聪明才智，误了自己的青春年华。 荷马史诗《奥德赛》中有一句至理名言：”没有比漫无目的地徘徊更令人无法忍受的了。”毕业后这5年里的迷茫，会造成10年后的恐慌，20年后的挣扎，甚至一辈子的平庸。如果不能在毕业这5年尽快冲出困惑、走出迷雾，我们实在是无颜面对10年后、20年后的自己。毕业这5年里，我们既有很多的不确定，也有很多的可能性。","text":"有人工作，有人上学，大家千万不要错过这篇文章，能看到这篇文章也是一种幸运，真的受益匪浅，对我有很大启迪，这篇文章将会改变你我的一生，真的太好了，希望与有缘人分享，也希望对有缘人有所帮助！看完之后有种“相见恨晚”的感觉，特别激动，希望大家好好的珍藏这篇文章，相信多年以后，再来看这篇文章，一定有不同的感觉。 正如”打工皇帝”唐骏说：”我觉得有两种人不要跟别人争利益和价值回报。第一种人就是刚刚进入企业的人，头5年千万不要说你能不能多给我一点儿工资，最重要的是能在企业里学到什么，对发展是不是有利……” 人总是从平坦中获得的教益少，从磨难中获得的教益多；从平坦中获得的教益浅，从磨难中获得的教益深。一个人在年轻时经历磨难，如能正确视之，冲出黑暗，那就是一个值得敬慕的人。最要紧的是先练好内功，毕业后这5年就是练内功的最佳时期，练好内功，才有可能在未来攀得更高。 出路在哪里？出路在于思路！ 其实，没有钱、没有经验、没有阅历、没有社会关系，这些都不可怕。没有钱，可以通过辛勤劳动去赚；没有经验，可以通过实践操作去总结；没有阅历，可以一步一步去积累；没有社会关系，可以一点一点去编织。但是，没有梦想、没有思路才是最可怕的，才让人感到恐惧，很想逃避! 人必须有一个正确的方向。无论你多么意气风发，无论你是多么足智多谋，无论你花费了多大的心血，如果没有一个明确的方向，就会过得很茫然，渐渐就丧失了斗志，忘却了最初的梦想，就会走上弯路甚至不归路，枉费了自己的聪明才智，误了自己的青春年华。 荷马史诗《奥德赛》中有一句至理名言：”没有比漫无目的地徘徊更令人无法忍受的了。”毕业后这5年里的迷茫，会造成10年后的恐慌，20年后的挣扎，甚至一辈子的平庸。如果不能在毕业这5年尽快冲出困惑、走出迷雾，我们实在是无颜面对10年后、20年后的自己。毕业这5年里，我们既有很多的不确定，也有很多的可能性。 毕业这5年里，我们既有很多的待定，也有很多的决定。 迷茫与困惑谁都会经历，恐惧与逃避谁都曾经有过，但不要把迷茫与困惑当作可以自我放弃、甘于平庸的借口，更不要成为自怨自艾、祭奠失意的苦酒。生命需要自己去承担，命运更需要自己去把握。在毕业这5年里，越早找到方向，越早走出困惑，就越容易在人生道路上取得成就、创造精彩。无头苍蝇找不到方向，才会四处碰壁；一个人找不到出路，才会迷茫、恐惧。 生活中，面对困境，我们常常会有走投无路的感觉。不要气馁，坚持下去，要相信年轻的人生没有绝路，困境在前方，希望在拐角。只要我们有了正确的思路，就一定能少走弯路，找到出路！ 成功的人不是赢在起点，而是赢在转折点。 不少刚刚毕业的年轻人，总是奢望马上就能找到自己理想中的工作。然而，很多好工作是无法等来的，你必须选择一份工作作为历练。职业旅程中的第一份工作，无疑是踏入社会这所大学的起点。也许你找了一份差强人意的工作，那么从这里出发，好好地沉淀自己，从这份工作中汲取到有价值的营养，厚积薄发。千里之行，始于足下，只要出发，就有希望到达终点。 起点可以相同，但是选择了不同的拐点，终点就会大大不同！ 毕业这几年，我们的生活、感情、职业等都存在很多不确定的因素，未来也充满了各种可能。这个时候，必须学会选择，懂得放弃，给自己一个明确的定位，使自己稳定下来。如果你不主动定位，就会被别人和社会”定型”！ 可以这么说：一个人在毕业这5年培养起来的行为习惯，将决定他一生的高度。我们能否成功，在某种程度上取决于自己对自己的评价，这就是定位。你给自己定位是什么，你就是什么。定位能决定人生，定位能改变命运。丑小鸭变成白天鹅，只要一双翅膀；灰姑娘变成美公主，只要一双水晶鞋。 人的命，三分天注定，七分靠打拼，有梦就”会红”，爱拼才会赢。只要不把自己束缚在心灵的牢笼里，谁也束缚不了你去展翅高飞。 现实情况远非他们所想的那样。于是，当优越感逐渐转为失落感甚至挫败感时，当由坚信自己是一块”金子”到怀疑自己是一粒”沙子”时，愤怒、迷茫、自卑就开始与日俱增。 其实，应该仔细掂量一下自己，你是否真是金子？是真金，手中要有绝活，才能上要有过人之处才行。一句话：真金是要靠实力来证明的，只有先把自己的本领修炼好了，才有资格考虑伯乐的事情 每颗珍珠原本都是一粒沙子，但并不是每一粒沙子都能成为一颗珍珠。 想要卓尔不群，就要有鹤立鸡群的资本。忍受不了打击和挫折，承受不住忽视和平淡，就很难达到辉煌。年轻人要想让自己得到重用，取得成功，就必须把自己从一粒沙子变成一颗价值连城的珍珠。 天有下雨与日出，人生高峰与低谷。 莫为浮云遮望眼，风物长宜放眼量。 只要拂去阴霾，就能亮出朗朗晴空。如果你在工作上有些不如意，要相信自己不会一直处于人生的低谷期，总有一天能冲破重重云层。告诉自己：我并没有失败，只是暂时没有成功！只要在内心点亮一盏希望之灯，一定能驱散黑暗中的阴霾，迎来光明。 的确，论资历，他们是不折不扣的职场菜鸟，业务涉及不深，人脉一穷二白，在工作中经常碰壁。他们的压力并不一定都像千钧大石，而是像大雨来临前的天色，灰色低沉，明明有空间，却被灰色填满每个缝隙，只能等待大雨倾盆之后的晴空。 “起得比鸡早，睡得比狗晚，干得比驴多，吃得比猪差。”这是很多刚刚毕业的人喜欢用来调侃自己生活状态的话。虽然有点儿夸张，但是，他们中的很多人的确一直都被灰色心情所笼罩–心里永远是多云转阴。记得有位哲人曾说：”我们的痛苦不是问题本身带来的，而是我们对这些问题的看法产生的。”换个角度看人生，是一种突破、一种解脱、一种超越、一种高层次的淡泊与宁静，从而获得自由自在的快乐。 一位哲人说：”人生就是一连串的抉择，每个人的前途与命运，完全把握在自己手中，只要努力，终会有成。”就业也好，择业也罢，创业亦如此，只要奋发努力，都会成功。你是不是准备把生命的承诺全部都交给别人？ 毕业后这5年，是改变自己命运的黄金时期。在最能决定自己命运时，如果还不把握，那你还要等到什么时候呢？我的人生我做主，命运由己不由人。 不要活在别人的嘴里，不要活在别人的眼里，而是把命运握在自己手里。 别说你没有背景，自己就是最大的背景。美国作家杰克·凯鲁亚克说过一句话：”我还年轻，我渴望上路。”在人生的旅途中，我们永远都是年轻人，每天都应该满怀渴望。每个人的潜能都是无限的，关键是要发现自己的潜能和正确认识自己的才能，并找到一个能充分发挥潜能的舞台，而不能只为舞台的不合适感到不快。要客观公正地看待自己的能力，结合自己的实际情况和爱好冷静选择，尽可能到最需要自己、最适合自己的地方。 在人力资源管理界，特别流行一个说法，即”骑马，牵牛，赶猪，打狗”理论：人品很好，能力又很强的，是千里马，我们要骑着他；人品很好但能力普通的，是老黄牛，我们要牵着他；人品、能力皆普通的，就是”猪”，我们要赶走他；人品很差能力很强的，那是”狗”，我们要打击他。 我想，刚刚毕业几年的你，一样胸怀大志，一样想成为一匹被人赏识、驰骋沙场的千里马吧？那么，就好好沉淀下来。低就一层不等于低人一等，今日的俯低是为了明天的高就。所谓生命的价值，就是我们的存在对别人有价值。能被人利用是一件好事，无人问津才是真正的悲哀！ 能干工作、干好工作是职场生存的基本保障。 任何人做工作的前提条件都是他的能力能够胜任这项工作。能干是合格员工最基本的标准，肯干则是一种态度。一个职位有很多人都能胜任，都有干好这份工作的基本能力，然而，能否把工作做得更好一些，就要看是否具有踏实肯干、苦于钻研的工作态度了。 在能干的基础上踏实肯干。 工作中，活干得比别人多，你觉得吃亏；钱拿得比别人少，你觉得吃亏；经常加班加点，你觉得吃亏……其实，没必要这样计较，吃亏不是灾难，不是失败，吃亏也是一种生活哲学。现在吃点儿小亏，为成功铺就道路，也许在未来的某个时刻，你的大福突然就来了。 能吃亏是做人的一种境界，是处世的一种睿智。 在工作中并不是多做事或多帮别人干点儿活就是吃亏。如果领导让你加加班、赶赶任务，别以为自己吃了大亏，反而应该感到庆幸，因为领导只叫了你，而没叫其他人，说明他信任你、赏识你。吃亏是一种贡献，你贡献得越多，得到的回报也就越多。乐于加班，就是这样的一种吃亏。 舍得舍得，有舍才有得；学会在适当时吃些亏的人绝对不是弱智，而是大智。 给别人留余地就是给自己留余地，予人方便就是予己方便，善待别人就是善待自己。 傻人有傻福，因为傻人没有心计。和这样的人在一起，身心放松，没有太多警惕，就能相互靠近。傻在很多时候意味着执着和忠贞，也意味着宽厚和诚实，让人不知不觉站到他一边。傻人无意中得到的，比聪明人费尽心机得到的还多。毕业这几年，你的天空中只飘着几片雪花，这样你就满足了吗？成功需要坚持与积累，与其专注于搜集雪花，不如省下力气去滚雪球。巴菲特说：”人生就像滚雪球，最重要的是发现很湿的雪和很长的坡。”让自己沉淀下来，学着发现”很湿的雪”，努力寻找”很长的坡”。记住：散落的雪花会很快融化，化为乌有，只有雪球才更实在，才能长久。在毕业这几年里，你要是能做到比别人多付出一分努力，就意味着比别人多积累一分资本，就比别人多一次成功的机会。 什么是职业化呢？职业化就是工作状态的标准化、规范化、制度化，即在合适的时间、合适的地点用合适的方式说合适的话、做合适的事，使知识、技能、观念、思维、态度、心理等符合职业规范和标准。”在每个行业里，都有很多出色的人才，他们之所以能存在，是因为比别人更努力、更智慧、更成熟。但是，最重要的是，他们比一般人更加职业化！这就是为什么我现在能当你老板的原因。一个人仅仅专业化是不够的，只有职业化的人才能飞在别人前面，让人难以超越！”不要以为我们现在已经生存得很安稳了。对于毕业5年的人来讲，一定要认清即将面临的五大挑战。 一、赡养父母。二、结婚生子。三、升职加薪。四、工作压力。五、生活质量。 有的人为生存而雀跃，目光总是停在身后，三天打鱼两天晒网，有始无终。 有的人为发展而奋斗，目光总是盯在正前方，每天进步一点点，坚持不懈。 毕业这几年，不能没有追求和探索，不能没有理想和目标。人生如逆水行舟，不进则退。甘于现状的生活就是不再前行的船，再也无法追上时代前进的步伐。一定要抓紧每一秒钟的时间来学习，要明白学习不是学生的专利。小聪明的人最得意的是：自己做过什么？大智慧的人最渴望的是：自己还要做什么？ 小聪明是战术，大智慧是战略；小聪明看到的是芝麻，大智慧看到的是西瓜。 在这个世界上，既有大人物，也有小角色，大人物有大人物的活法，小人物有小人物的潇洒，每个人都有自己的生活方式，谁也勉强不了谁。但是，小聪明只能有小成绩和小视野，大智慧才能有大成就和大境界。小企业看老板，中企业看制度，大企业看文化。 小公司与大企业都有生存之道，没有好坏之分，但对一个人不同阶段的影响会不同。 小公司肯定想要发展为大企业，这是一种目标，年轻人也要给自己的职业生涯制定目标。毕业几年的你，是否经常会怯场或者是感到没有底气？居安思危绝对不是危言耸听！此刻打盹，你将做梦；此刻学习，你将圆梦。在竞争激烈的人生战场上，打盹的都是输家！ 每个人在年轻的时候似乎都豪情万丈，什么都不怕，可是随着年龄的增长，每天想着房子、工作、养家糊口这些俗事儿，再也没有年轻时那种敢于”上天探星、下海捞月”的勇气了。是我们改变了生活，还是生活改变了我们？我们的思想越来越复杂，因为有了越来越多的舍不得、越来越多的顾虑，我们总是在徘徊、总是在犹豫。毕业开始一两年，生活的重担会压得我们喘不过气来，挫折和障碍堵住四面八方的通口，我们往往在压迫得自己发挥出潜能后，才能杀出重围，找到出路。可是两三年后，身上的重担开始减轻，工作开始一帆风顺，我们就松懈了下来，渐渐忘记了潜在的危险。直到有一天危机突然降临，我们在手足无措中被击败……毕业这几年，仍然处于危险期，一定要有居安思危的意识，好好打拼，这样才能有一个真正的安全人生！ 生于忧患，死于安乐。如果你想跨越自己目前的成就，就不能画地自限，而是要勇于接受挑战。对畏畏缩缩的人来说，真正的危险正在于不敢冒险！ 年轻人在社会的重压下，适应能力已变得越来越强，只是他们不自觉地习惯被环境推着走。他们不敢冒险，怕给自己带来终身的遗憾，于是告慰自己：”我对得起自己、对得起家人，因为我已竭尽全力。”其实，人只有不断挑战和突破才能逐渐成长。长期固守于已有的安全感中，就会像温水里的青蛙一样，最终失去跳跃的本能。 经历了这几年社会生活，你应该明白：这个世界上有富也有贫，有阴也有亮，有丑也有美，到底看到什么，取决于自己是积极还是消极。在年轻时学会勤勉地工作，用一种光明的思维对待生活，那么，只要张开手掌，你就会发现，里面有一片灿烂的人生。 把感恩刻在石头上，深深地感谢别人帮助过你，永远铭记，这是人生应有的一种境界；把仇恨写在沙滩上，淡淡忘掉别人伤害过你，学会宽容，让所有的怨恨随着潮水一去不复返，这也是一种人生境界。 学会倒出水，才能装下更多的水。从毕业那天开始，学会把每天都当成一个新的起点，每一次工作都从零开始。如果你懂得把”归零”当成一种生活的常态，当成一种优秀的延续，当成一种时刻要做的事情，那么，经过短短几年，你就可以完成自己职业生涯的正确规划与全面超越。 在职业起步的短短道路上，想要得到更好、更快、更有益的成长，就必须以归零思维来面对这个世界。不要以大学里的清高来标榜自己，不要觉得自己特别优秀，而是要把自己的姿态放下，把自己的身架放低，让自己沉淀下来，抱着学习的态度去适应环境、接受挑战。放下”身段”才能提高身价，暂时的俯低终会促成未来的高就。 年轻人从校园或者从一个环境进入一个新环境，就要勇于将原来环境里熟悉、习惯、喜欢的东西放下，然后从零开始。我们想在职场上获得成功，首先就要培养适应力。从自然人转化为单位人是融入职场的基本条件。一个人起点低并不可怕，怕的是境界低。越计较自我，便越没有发展前景；相反，越是主动付出，那么他就越会快速发展。很多今天取得一定成就的人，在职业生涯的初期都是从零开始，把自己沉淀再沉淀、倒空再倒空、归零再归零，正因为这样，他们的人生才一路高歌，一路飞扬。 在毕业这几年里，我们要让过去归零，才不会成为职场上那只背着重壳爬行的蜗牛，才能像天空中的鸟儿那样轻盈地飞翔。请好好品味一下杰克·韦尔奇说过的一句话：”纠正自己的行为，认清自己，从零开始，你将重新走上职场坦途。” 吐故才能纳新，心静才能身凉，有舍才能有得，杯空才能水满，放下才能超越。 归零思维五大表现：心中无我，眼中无钱，念中无他，朝中无人，学无止境。 年轻人难免带着几分傲气，认为自己无所不能、所向披靡，其实不然，初入职场的新人还是个”婴儿”，正处在从爬到走的成长阶段。在毕业这几年里，一定要让自己逐步培养起学徒思维、海绵思维、空杯思维，具有这样思维的人心灵总是敞开的，能随时接受启示和一切能激发灵感的东西，他们时刻都能感受到成功女神的召唤。","categories":[],"tags":[{"name":"励志","slug":"励志","permalink":"http://cnkcq.github.io/tags/励志/"},{"name":"收录","slug":"收录","permalink":"http://cnkcq.github.io/tags/收录/"}]},{"title":"Swift：如何动态初始化一个类","slug":"Swift——动态初始化一个类","date":"2015-04-10T09:50:10.000Z","updated":"2017-09-22T08:01:40.058Z","comments":true,"path":"2015/04/10/Swift——动态初始化一个类/","link":"","permalink":"http://cnkcq.github.io/2015/04/10/Swift——动态初始化一个类/","excerpt":"一、产品需求 现在市面上的APP有很多都有这样一个需求，那就是tabBarItem的动态配置，也就是如果节假日呀或者什么特殊日子呀tabBarItem的icon和title就有后台配置一下就可以改变了。","text":"一、产品需求 现在市面上的APP有很多都有这样一个需求，那就是tabBarItem的动态配置，也就是如果节假日呀或者什么特殊日子呀tabBarItem的icon和title就有后台配置一下就可以改变了。 二、命名空间 有一定经验的人都知道，要实现上面的需求，iOS端必须要动态创建类，在oc中这个好办： 12Class cls = NSClassFromString(@\"NewsViewController\");[self.navigationController pushViewController:cls.new animated:YES]; 但是在Swift中就没有这么简单了，总所周知oc是没有命名空间的，而Swift有命名空间，在 swift 中，类名是包含命名空间的，命名空间默认是项目名称，同一个命名空间全局共享，如果新建项目时，项目名称中包含有中文，可以按照下图修改： 命名空间我们可以从info.plist配置文件里面或取: 1let namespace = NSBundle.mainBundle().infoDictionary![\"CFBundleExecutable\"] as! String 在Swift中我们就可以这样动态的初始化一个类了： 123let clsName = namespace + \".\" + \"NewsViewController\"let cls: AnyClass = NSClassFromString(clsName)!let vc = cls.alloc() as! UITableViewController","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://cnkcq.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://cnkcq.github.io/tags/Swift/"},{"name":"动态加载","slug":"动态加载","permalink":"http://cnkcq.github.io/tags/动态加载/"}]},{"title":"一步一步搭建Hexo博客","slug":"一步一步搭建Hexo博客","date":"2015-02-20T09:58:12.000Z","updated":"2017-09-22T08:01:40.058Z","comments":true,"path":"2015/02/20/一步一步搭建Hexo博客/","link":"","permalink":"http://cnkcq.github.io/2015/02/20/一步一步搭建Hexo博客/","excerpt":"个人博客快速入门一、生成个人主页 注册一个github账号，创建一个以你用户名为前缀的仓库，例如：KingCQ.github.com,点击仓库的设置（Settings）进入里面生成 GitHubPages 成功完成相应操作后你会看到 Your site is published at http://kingcq.github.io. 打开这个网页，这就是你的pages页面了","text":"个人博客快速入门一、生成个人主页 注册一个github账号，创建一个以你用户名为前缀的仓库，例如：KingCQ.github.com,点击仓库的设置（Settings）进入里面生成 GitHubPages 成功完成相应操作后你会看到 Your site is published at http://kingcq.github.io. 打开这个网页，这就是你的pages页面了 二、添加SSH Keys 生成密钥： 1$ssh-keygen -t rsa -C \"wangchengqvan@hotmail.com\" 上述命令若执行成功，会在H:\\git\\myssh目录下生成两个文件id_rsa和id_rsa.pub，最后两步： 用文本编辑器打开ssh.pub文件，拷贝其中的内容，将其添加到Add SSH Key 好，我们来验证一下： 1$ssh -T git@github.com 如果出现Permission denied (publickey).（addkey哪一步可能出现了问题） 仔细检查，可能是密钥失效或者拼写错误，重新来一次，成功后会有如下提示： 1Hi username! You've successfully authenticated... 三、安装Hexo 假设你已经安装好了npm，如果没有请自行Google 1$npm install -g hexo 然后，执行init命令初始化hexo到你指定的目录： 1$ hexo init &lt;folder&gt; 好啦，至此，全部安装工作已经完成！ 四、生成静态网页 cd 到你的init目录，执行如下命令，生成静态页面至hexo\\public\\目录。 1$hexo generate 命令必须在init目录下执行，否则不成功，但是也不报错 把生成的网页部署到服务器,执行命令 1$hexo deploy More info: Deployment 在执行 hexo deploy 后,如果出现 error deployer not found:github 的错误 12345678$npm install hexo-deployer-git --save``` 改了之后执行，然后再部署试试本地启动执行如下命令，启动本地服务，进行文章预览调试。``` bash$hexo server 用浏览器打开(http://localhost:4000) 你就可以欣赏到hexo个人主页的效果了。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://cnkcq.github.io/tags/iOS/"},{"name":"博客","slug":"博客","permalink":"http://cnkcq.github.io/tags/博客/"},{"name":"Hexo","slug":"Hexo","permalink":"http://cnkcq.github.io/tags/Hexo/"}]}]}